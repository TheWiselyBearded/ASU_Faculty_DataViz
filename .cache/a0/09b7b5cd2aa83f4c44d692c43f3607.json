{"id":"node_modules/webcola/dist/src/rectangle.js","dependencies":[{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/rectangle.js.map","includedInParent":true,"mtime":1517462217000},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/WebCola/src/rectangle.ts","includedInParent":true,"mtime":1516884256000},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/package.json","includedInParent":true,"mtime":1550967406043},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/package.json","includedInParent":true,"mtime":1550967405642},{"name":"./vpsc","loc":{"line":13,"column":21},"parent":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/rectangle.js","resolved":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/vpsc.js"},{"name":"./rbtree","loc":{"line":14,"column":23},"parent":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/rectangle.js","resolved":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/rbtree.js"}],"generated":{"js":"\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar vpsc_1 = require(\"./vpsc\");\r\nvar rbtree_1 = require(\"./rbtree\");\r\nfunction computeGroupBounds(g) {\r\n    g.bounds = typeof g.leaves !== \"undefined\" ?\r\n        g.leaves.reduce(function (r, c) { return c.bounds.union(r); }, Rectangle.empty()) :\r\n        Rectangle.empty();\r\n    if (typeof g.groups !== \"undefined\")\r\n        g.bounds = g.groups.reduce(function (r, c) { return computeGroupBounds(c).union(r); }, g.bounds);\r\n    g.bounds = g.bounds.inflate(g.padding);\r\n    return g.bounds;\r\n}\r\nexports.computeGroupBounds = computeGroupBounds;\r\nvar Rectangle = (function () {\r\n    function Rectangle(x, X, y, Y) {\r\n        this.x = x;\r\n        this.X = X;\r\n        this.y = y;\r\n        this.Y = Y;\r\n    }\r\n    Rectangle.empty = function () { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); };\r\n    Rectangle.prototype.cx = function () { return (this.x + this.X) / 2; };\r\n    Rectangle.prototype.cy = function () { return (this.y + this.Y) / 2; };\r\n    Rectangle.prototype.overlapX = function (r) {\r\n        var ux = this.cx(), vx = r.cx();\r\n        if (ux <= vx && r.x < this.X)\r\n            return this.X - r.x;\r\n        if (vx <= ux && this.x < r.X)\r\n            return r.X - this.x;\r\n        return 0;\r\n    };\r\n    Rectangle.prototype.overlapY = function (r) {\r\n        var uy = this.cy(), vy = r.cy();\r\n        if (uy <= vy && r.y < this.Y)\r\n            return this.Y - r.y;\r\n        if (vy <= uy && this.y < r.Y)\r\n            return r.Y - this.y;\r\n        return 0;\r\n    };\r\n    Rectangle.prototype.setXCentre = function (cx) {\r\n        var dx = cx - this.cx();\r\n        this.x += dx;\r\n        this.X += dx;\r\n    };\r\n    Rectangle.prototype.setYCentre = function (cy) {\r\n        var dy = cy - this.cy();\r\n        this.y += dy;\r\n        this.Y += dy;\r\n    };\r\n    Rectangle.prototype.width = function () {\r\n        return this.X - this.x;\r\n    };\r\n    Rectangle.prototype.height = function () {\r\n        return this.Y - this.y;\r\n    };\r\n    Rectangle.prototype.union = function (r) {\r\n        return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\r\n    };\r\n    Rectangle.prototype.lineIntersections = function (x1, y1, x2, y2) {\r\n        var sides = [[this.x, this.y, this.X, this.y],\r\n            [this.X, this.y, this.X, this.Y],\r\n            [this.X, this.Y, this.x, this.Y],\r\n            [this.x, this.Y, this.x, this.y]];\r\n        var intersections = [];\r\n        for (var i = 0; i < 4; ++i) {\r\n            var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\r\n            if (r !== null)\r\n                intersections.push({ x: r.x, y: r.y });\r\n        }\r\n        return intersections;\r\n    };\r\n    Rectangle.prototype.rayIntersection = function (x2, y2) {\r\n        var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\r\n        return ints.length > 0 ? ints[0] : null;\r\n    };\r\n    Rectangle.prototype.vertices = function () {\r\n        return [\r\n            { x: this.x, y: this.y },\r\n            { x: this.X, y: this.y },\r\n            { x: this.X, y: this.Y },\r\n            { x: this.x, y: this.Y }\r\n        ];\r\n    };\r\n    Rectangle.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {\r\n        var dx12 = x2 - x1, dx34 = x4 - x3, dy12 = y2 - y1, dy34 = y4 - y3, denominator = dy34 * dx12 - dx34 * dy12;\r\n        if (denominator == 0)\r\n            return null;\r\n        var dx31 = x1 - x3, dy31 = y1 - y3, numa = dx34 * dy31 - dy34 * dx31, a = numa / denominator, numb = dx12 * dy31 - dy12 * dx31, b = numb / denominator;\r\n        if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\r\n            return {\r\n                x: x1 + a * dx12,\r\n                y: y1 + a * dy12\r\n            };\r\n        }\r\n        return null;\r\n    };\r\n    Rectangle.prototype.inflate = function (pad) {\r\n        return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\r\n    };\r\n    return Rectangle;\r\n}());\r\nexports.Rectangle = Rectangle;\r\nfunction makeEdgeBetween(source, target, ah) {\r\n    var si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() }, ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() }, dx = ti.x - si.x, dy = ti.y - si.y, l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\r\n    return {\r\n        sourceIntersection: si,\r\n        targetIntersection: ti,\r\n        arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }\r\n    };\r\n}\r\nexports.makeEdgeBetween = makeEdgeBetween;\r\nfunction makeEdgeTo(s, target, ah) {\r\n    var ti = target.rayIntersection(s.x, s.y);\r\n    if (!ti)\r\n        ti = { x: target.cx(), y: target.cy() };\r\n    var dx = ti.x - s.x, dy = ti.y - s.y, l = Math.sqrt(dx * dx + dy * dy);\r\n    return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };\r\n}\r\nexports.makeEdgeTo = makeEdgeTo;\r\nvar Node = (function () {\r\n    function Node(v, r, pos) {\r\n        this.v = v;\r\n        this.r = r;\r\n        this.pos = pos;\r\n        this.prev = makeRBTree();\r\n        this.next = makeRBTree();\r\n    }\r\n    return Node;\r\n}());\r\nvar Event = (function () {\r\n    function Event(isOpen, v, pos) {\r\n        this.isOpen = isOpen;\r\n        this.v = v;\r\n        this.pos = pos;\r\n    }\r\n    return Event;\r\n}());\r\nfunction compareEvents(a, b) {\r\n    if (a.pos > b.pos) {\r\n        return 1;\r\n    }\r\n    if (a.pos < b.pos) {\r\n        return -1;\r\n    }\r\n    if (a.isOpen) {\r\n        return -1;\r\n    }\r\n    if (b.isOpen) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction makeRBTree() {\r\n    return new rbtree_1.RBTree(function (a, b) { return a.pos - b.pos; });\r\n}\r\nvar xRect = {\r\n    getCentre: function (r) { return r.cx(); },\r\n    getOpen: function (r) { return r.y; },\r\n    getClose: function (r) { return r.Y; },\r\n    getSize: function (r) { return r.width(); },\r\n    makeRect: function (open, close, center, size) { return new Rectangle(center - size / 2, center + size / 2, open, close); },\r\n    findNeighbours: findXNeighbours\r\n};\r\nvar yRect = {\r\n    getCentre: function (r) { return r.cy(); },\r\n    getOpen: function (r) { return r.x; },\r\n    getClose: function (r) { return r.X; },\r\n    getSize: function (r) { return r.height(); },\r\n    makeRect: function (open, close, center, size) { return new Rectangle(open, close, center - size / 2, center + size / 2); },\r\n    findNeighbours: findYNeighbours\r\n};\r\nfunction generateGroupConstraints(root, f, minSep, isContained) {\r\n    if (isContained === void 0) { isContained = false; }\r\n    var padding = root.padding, gn = typeof root.groups !== 'undefined' ? root.groups.length : 0, ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0, childConstraints = !gn ? []\r\n        : root.groups.reduce(function (ccs, g) { return ccs.concat(generateGroupConstraints(g, f, minSep, true)); }, []), n = (isContained ? 2 : 0) + ln + gn, vs = new Array(n), rs = new Array(n), i = 0, add = function (r, v) { rs[i] = r; vs[i++] = v; };\r\n    if (isContained) {\r\n        var b = root.bounds, c = f.getCentre(b), s = f.getSize(b) / 2, open = f.getOpen(b), close = f.getClose(b), min = c - s + padding / 2, max = c + s - padding / 2;\r\n        root.minVar.desiredPosition = min;\r\n        add(f.makeRect(open, close, min, padding), root.minVar);\r\n        root.maxVar.desiredPosition = max;\r\n        add(f.makeRect(open, close, max, padding), root.maxVar);\r\n    }\r\n    if (ln)\r\n        root.leaves.forEach(function (l) { return add(l.bounds, l.variable); });\r\n    if (gn)\r\n        root.groups.forEach(function (g) {\r\n            var b = g.bounds;\r\n            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\r\n        });\r\n    var cs = generateConstraints(rs, vs, f, minSep);\r\n    if (gn) {\r\n        vs.forEach(function (v) { v.cOut = [], v.cIn = []; });\r\n        cs.forEach(function (c) { c.left.cOut.push(c), c.right.cIn.push(c); });\r\n        root.groups.forEach(function (g) {\r\n            var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\r\n            g.minVar.cIn.forEach(function (c) { return c.gap += gapAdjustment; });\r\n            g.minVar.cOut.forEach(function (c) { c.left = g.maxVar; c.gap += gapAdjustment; });\r\n        });\r\n    }\r\n    return childConstraints.concat(cs);\r\n}\r\nfunction generateConstraints(rs, vars, rect, minSep) {\r\n    var i, n = rs.length;\r\n    var N = 2 * n;\r\n    console.assert(vars.length >= n);\r\n    var events = new Array(N);\r\n    for (i = 0; i < n; ++i) {\r\n        var r = rs[i];\r\n        var v = new Node(vars[i], r, rect.getCentre(r));\r\n        events[i] = new Event(true, v, rect.getOpen(r));\r\n        events[i + n] = new Event(false, v, rect.getClose(r));\r\n    }\r\n    events.sort(compareEvents);\r\n    var cs = new Array();\r\n    var scanline = makeRBTree();\r\n    for (i = 0; i < N; ++i) {\r\n        var e = events[i];\r\n        var v = e.v;\r\n        if (e.isOpen) {\r\n            scanline.insert(v);\r\n            rect.findNeighbours(v, scanline);\r\n        }\r\n        else {\r\n            scanline.remove(v);\r\n            var makeConstraint = function (l, r) {\r\n                var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\r\n                cs.push(new vpsc_1.Constraint(l.v, r.v, sep));\r\n            };\r\n            var visitNeighbours = function (forward, reverse, mkcon) {\r\n                var u, it = v[forward].iterator();\r\n                while ((u = it[forward]()) !== null) {\r\n                    mkcon(u, v);\r\n                    u[reverse].remove(v);\r\n                }\r\n            };\r\n            visitNeighbours(\"prev\", \"next\", function (u, v) { return makeConstraint(u, v); });\r\n            visitNeighbours(\"next\", \"prev\", function (u, v) { return makeConstraint(v, u); });\r\n        }\r\n    }\r\n    console.assert(scanline.size === 0);\r\n    return cs;\r\n}\r\nfunction findXNeighbours(v, scanline) {\r\n    var f = function (forward, reverse) {\r\n        var it = scanline.findIter(v);\r\n        var u;\r\n        while ((u = it[forward]()) !== null) {\r\n            var uovervX = u.r.overlapX(v.r);\r\n            if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\r\n                v[forward].insert(u);\r\n                u[reverse].insert(v);\r\n            }\r\n            if (uovervX <= 0) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    f(\"next\", \"prev\");\r\n    f(\"prev\", \"next\");\r\n}\r\nfunction findYNeighbours(v, scanline) {\r\n    var f = function (forward, reverse) {\r\n        var u = scanline.findIter(v)[forward]();\r\n        if (u !== null && u.r.overlapX(v.r) > 0) {\r\n            v[forward].insert(u);\r\n            u[reverse].insert(v);\r\n        }\r\n    };\r\n    f(\"next\", \"prev\");\r\n    f(\"prev\", \"next\");\r\n}\r\nfunction generateXConstraints(rs, vars) {\r\n    return generateConstraints(rs, vars, xRect, 1e-6);\r\n}\r\nexports.generateXConstraints = generateXConstraints;\r\nfunction generateYConstraints(rs, vars) {\r\n    return generateConstraints(rs, vars, yRect, 1e-6);\r\n}\r\nexports.generateYConstraints = generateYConstraints;\r\nfunction generateXGroupConstraints(root) {\r\n    return generateGroupConstraints(root, xRect, 1e-6);\r\n}\r\nexports.generateXGroupConstraints = generateXGroupConstraints;\r\nfunction generateYGroupConstraints(root) {\r\n    return generateGroupConstraints(root, yRect, 1e-6);\r\n}\r\nexports.generateYGroupConstraints = generateYGroupConstraints;\r\nfunction removeOverlaps(rs) {\r\n    var vs = rs.map(function (r) { return new vpsc_1.Variable(r.cx()); });\r\n    var cs = generateXConstraints(rs, vs);\r\n    var solver = new vpsc_1.Solver(vs, cs);\r\n    solver.solve();\r\n    vs.forEach(function (v, i) { return rs[i].setXCentre(v.position()); });\r\n    vs = rs.map(function (r) { return new vpsc_1.Variable(r.cy()); });\r\n    cs = generateYConstraints(rs, vs);\r\n    solver = new vpsc_1.Solver(vs, cs);\r\n    solver.solve();\r\n    vs.forEach(function (v, i) { return rs[i].setYCentre(v.position()); });\r\n}\r\nexports.removeOverlaps = removeOverlaps;\r\nvar IndexedVariable = (function (_super) {\r\n    __extends(IndexedVariable, _super);\r\n    function IndexedVariable(index, w) {\r\n        var _this = _super.call(this, 0, w) || this;\r\n        _this.index = index;\r\n        return _this;\r\n    }\r\n    return IndexedVariable;\r\n}(vpsc_1.Variable));\r\nexports.IndexedVariable = IndexedVariable;\r\nvar Projection = (function () {\r\n    function Projection(nodes, groups, rootGroup, constraints, avoidOverlaps) {\r\n        if (rootGroup === void 0) { rootGroup = null; }\r\n        if (constraints === void 0) { constraints = null; }\r\n        if (avoidOverlaps === void 0) { avoidOverlaps = false; }\r\n        var _this = this;\r\n        this.nodes = nodes;\r\n        this.groups = groups;\r\n        this.rootGroup = rootGroup;\r\n        this.avoidOverlaps = avoidOverlaps;\r\n        this.variables = nodes.map(function (v, i) {\r\n            return v.variable = new IndexedVariable(i, 1);\r\n        });\r\n        if (constraints)\r\n            this.createConstraints(constraints);\r\n        if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\r\n            nodes.forEach(function (v) {\r\n                if (!v.width || !v.height) {\r\n                    v.bounds = new Rectangle(v.x, v.x, v.y, v.y);\r\n                    return;\r\n                }\r\n                var w2 = v.width / 2, h2 = v.height / 2;\r\n                v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\r\n            });\r\n            computeGroupBounds(rootGroup);\r\n            var i = nodes.length;\r\n            groups.forEach(function (g) {\r\n                _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n                _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n            });\r\n        }\r\n    }\r\n    Projection.prototype.createSeparation = function (c) {\r\n        return new vpsc_1.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== \"undefined\" ? c.equality : false);\r\n    };\r\n    Projection.prototype.makeFeasible = function (c) {\r\n        var _this = this;\r\n        if (!this.avoidOverlaps)\r\n            return;\r\n        var axis = 'x', dim = 'width';\r\n        if (c.axis === 'x')\r\n            axis = 'y', dim = 'height';\r\n        var vs = c.offsets.map(function (o) { return _this.nodes[o.node]; }).sort(function (a, b) { return a[axis] - b[axis]; });\r\n        var p = null;\r\n        vs.forEach(function (v) {\r\n            if (p) {\r\n                var nextPos = p[axis] + p[dim];\r\n                if (nextPos > v[axis]) {\r\n                    v[axis] = nextPos;\r\n                }\r\n            }\r\n            p = v;\r\n        });\r\n    };\r\n    Projection.prototype.createAlignment = function (c) {\r\n        var _this = this;\r\n        var u = this.nodes[c.offsets[0].node].variable;\r\n        this.makeFeasible(c);\r\n        var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\r\n        c.offsets.slice(1).forEach(function (o) {\r\n            var v = _this.nodes[o.node].variable;\r\n            cs.push(new vpsc_1.Constraint(u, v, o.offset, true));\r\n        });\r\n    };\r\n    Projection.prototype.createConstraints = function (constraints) {\r\n        var _this = this;\r\n        var isSep = function (c) { return typeof c.type === 'undefined' || c.type === 'separation'; };\r\n        this.xConstraints = constraints\r\n            .filter(function (c) { return c.axis === \"x\" && isSep(c); })\r\n            .map(function (c) { return _this.createSeparation(c); });\r\n        this.yConstraints = constraints\r\n            .filter(function (c) { return c.axis === \"y\" && isSep(c); })\r\n            .map(function (c) { return _this.createSeparation(c); });\r\n        constraints\r\n            .filter(function (c) { return c.type === 'alignment'; })\r\n            .forEach(function (c) { return _this.createAlignment(c); });\r\n    };\r\n    Projection.prototype.setupVariablesAndBounds = function (x0, y0, desired, getDesired) {\r\n        this.nodes.forEach(function (v, i) {\r\n            if (v.fixed) {\r\n                v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\r\n                desired[i] = getDesired(v);\r\n            }\r\n            else {\r\n                v.variable.weight = 1;\r\n            }\r\n            var w = (v.width || 0) / 2, h = (v.height || 0) / 2;\r\n            var ix = x0[i], iy = y0[i];\r\n            v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\r\n        });\r\n    };\r\n    Projection.prototype.xProject = function (x0, y0, x) {\r\n        if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints))\r\n            return;\r\n        this.project(x0, y0, x0, x, function (v) { return v.px; }, this.xConstraints, generateXGroupConstraints, function (v) { return v.bounds.setXCentre(x[v.variable.index] = v.variable.position()); }, function (g) {\r\n            var xmin = x[g.minVar.index] = g.minVar.position();\r\n            var xmax = x[g.maxVar.index] = g.maxVar.position();\r\n            var p2 = g.padding / 2;\r\n            g.bounds.x = xmin - p2;\r\n            g.bounds.X = xmax + p2;\r\n        });\r\n    };\r\n    Projection.prototype.yProject = function (x0, y0, y) {\r\n        if (!this.rootGroup && !this.yConstraints)\r\n            return;\r\n        this.project(x0, y0, y0, y, function (v) { return v.py; }, this.yConstraints, generateYGroupConstraints, function (v) { return v.bounds.setYCentre(y[v.variable.index] = v.variable.position()); }, function (g) {\r\n            var ymin = y[g.minVar.index] = g.minVar.position();\r\n            var ymax = y[g.maxVar.index] = g.maxVar.position();\r\n            var p2 = g.padding / 2;\r\n            g.bounds.y = ymin - p2;\r\n            ;\r\n            g.bounds.Y = ymax + p2;\r\n        });\r\n    };\r\n    Projection.prototype.projectFunctions = function () {\r\n        var _this = this;\r\n        return [\r\n            function (x0, y0, x) { return _this.xProject(x0, y0, x); },\r\n            function (x0, y0, y) { return _this.yProject(x0, y0, y); }\r\n        ];\r\n    };\r\n    Projection.prototype.project = function (x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {\r\n        this.setupVariablesAndBounds(x0, y0, desired, getDesired);\r\n        if (this.rootGroup && this.avoidOverlaps) {\r\n            computeGroupBounds(this.rootGroup);\r\n            cs = cs.concat(generateConstraints(this.rootGroup));\r\n        }\r\n        this.solve(this.variables, cs, start, desired);\r\n        this.nodes.forEach(updateNodeBounds);\r\n        if (this.rootGroup && this.avoidOverlaps) {\r\n            this.groups.forEach(updateGroupBounds);\r\n            computeGroupBounds(this.rootGroup);\r\n        }\r\n    };\r\n    Projection.prototype.solve = function (vs, cs, starting, desired) {\r\n        var solver = new vpsc_1.Solver(vs, cs);\r\n        solver.setStartingPositions(starting);\r\n        solver.setDesiredPositions(desired);\r\n        solver.solve();\r\n    };\r\n    return Projection;\r\n}());\r\nexports.Projection = Projection;\r\n","map":{"version":3,"file":"rectangle.js","sourceRoot":"","sources":["../../WebCola/src/rectangle.ts"],"names":[],"mappings":"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","sourcesContent":["import {Constraint, Variable, Solver} from './vpsc'\r\nimport {RBTree} from './rbtree'\r\nimport {Point} from './geom'\r\n\r\n    export interface Leaf {\r\n        bounds: Rectangle;\r\n        variable: Variable;\r\n    }\r\n\r\n    export interface ProjectionGroup {\r\n        bounds: Rectangle;\r\n        padding: number;\r\n        stiffness: number;\r\n        leaves: Leaf[];\r\n        groups: ProjectionGroup[];\r\n        minVar: Variable;\r\n        maxVar: Variable;\r\n    }\r\n\r\n    export function computeGroupBounds(g: ProjectionGroup): Rectangle {\r\n        g.bounds = typeof g.leaves !== \"undefined\" ?\r\n            g.leaves.reduce((r: Rectangle, c) => c.bounds.union(r), Rectangle.empty()) :\r\n            Rectangle.empty();\r\n        if (typeof g.groups !== \"undefined\")\r\n            g.bounds = <Rectangle>g.groups.reduce((r: Rectangle, c) => computeGroupBounds(c).union(r), g.bounds);\r\n        g.bounds = g.bounds.inflate(g.padding);\r\n        return g.bounds;\r\n    }\r\n\r\n    export class Rectangle {\r\n        constructor(\r\n            public x: number,\r\n            public X: number,\r\n            public y: number,\r\n            public Y: number) { }\r\n\r\n        static empty(): Rectangle { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); }\r\n\r\n        cx(): number { return (this.x + this.X) / 2; }\r\n\r\n        cy(): number { return (this.y + this.Y) / 2; }\r\n\r\n        overlapX(r: Rectangle): number {\r\n            var ux = this.cx(), vx = r.cx();\r\n            if (ux <= vx && r.x < this.X) return this.X - r.x;\r\n            if (vx <= ux && this.x < r.X) return r.X - this.x;\r\n            return 0;\r\n        }\r\n\r\n        overlapY(r: Rectangle): number {\r\n            var uy = this.cy(), vy = r.cy();\r\n            if (uy <= vy && r.y < this.Y) return this.Y - r.y;\r\n            if (vy <= uy && this.y < r.Y) return r.Y - this.y;\r\n            return 0;\r\n        }\r\n\r\n        setXCentre(cx: number): void {\r\n            var dx = cx - this.cx();\r\n            this.x += dx;\r\n            this.X += dx;\r\n        }\r\n\r\n        setYCentre(cy: number): void {\r\n            var dy = cy - this.cy();\r\n            this.y += dy;\r\n            this.Y += dy;\r\n        }\r\n\r\n        width(): number {\r\n            return this.X - this.x;\r\n        }\r\n\r\n        height(): number {\r\n            return this.Y - this.y;\r\n        }\r\n\r\n        union(r: Rectangle): Rectangle {\r\n            return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\r\n        }\r\n\r\n        /**\r\n         * return any intersection points between the given line and the sides of this rectangle\r\n         * @method lineIntersection\r\n         * @param x1 number first x coord of line\r\n         * @param y1 number first y coord of line\r\n         * @param x2 number second x coord of line\r\n         * @param y2 number second y coord of line\r\n         * @return any intersection points found\r\n         */\r\n        lineIntersections(x1: number, y1: number, x2: number, y2: number): Array<Point> {\r\n            var sides = [[this.x, this.y, this.X, this.y],\r\n                    [this.X, this.y, this.X, this.Y],\r\n                    [this.X, this.Y, this.x, this.Y],\r\n                [this.x, this.Y, this.x, this.y]];\r\n            var intersections = [];\r\n            for (var i = 0; i < 4; ++i) {\r\n                var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\r\n                if (r !== null) intersections.push({ x: r.x, y: r.y });\r\n            }\r\n            return intersections;\r\n        }\r\n\r\n        /**\r\n         * return any intersection points between a line extending from the centre of this rectangle to the given point,\r\n         *  and the sides of this rectangle\r\n         * @method lineIntersection\r\n         * @param x2 number second x coord of line\r\n         * @param y2 number second y coord of line\r\n         * @return any intersection points found\r\n         */\r\n        rayIntersection(x2: number, y2: number): Point {\r\n            var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\r\n            return ints.length > 0 ? ints[0] : null;\r\n        }\r\n\r\n        vertices(): Point[] {\r\n            return [\r\n                { x: this.x, y: this.y },\r\n                { x: this.X, y: this.y },\r\n                { x: this.X, y: this.Y },\r\n                { x: this.x, y: this.Y }];\r\n        }\r\n\r\n        static lineIntersection(\r\n            x1: number, y1: number,\r\n            x2: number, y2: number,\r\n            x3: number, y3: number,\r\n            x4: number, y4: number): Point {\r\n            var dx12 = x2 - x1, dx34 = x4 - x3,\r\n                dy12 = y2 - y1, dy34 = y4 - y3,\r\n                denominator = dy34 * dx12 - dx34 * dy12;\r\n            if (denominator == 0) return null;\r\n            var dx31 = x1 - x3, dy31 = y1 - y3,\r\n                numa = dx34 * dy31 - dy34 * dx31,\r\n                a = numa / denominator,\r\n                numb = dx12 * dy31 - dy12 * dx31,\r\n                b = numb / denominator;\r\n            if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\r\n                return {\r\n                    x: x1 + a * dx12,\r\n                    y: y1 + a * dy12\r\n                };\r\n            }\r\n            return null;\r\n        }\r\n\r\n        inflate(pad: number): Rectangle {\r\n            return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the endpoints of a line that connects the centre of two rectangles.\r\n     * @param {Rectangle} [source] The source Rectangle.\r\n     * @param {Rectangle} [target] The target Rectangle.\r\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\r\n     *                      line by.\r\n     * @return An object with three point properties, the intersection with the\r\n     *         source rectangle (sourceIntersection), the intersection with then\r\n     *         target rectangle (targetIntersection), and the point an arrow\r\n     *         head of the specified size would need to start (arrowStart).\r\n     */\r\n    export function makeEdgeBetween(source: Rectangle, target: Rectangle, ah: number)\r\n        : { sourceIntersection: Point; targetIntersection: Point; arrowStart: Point } {\r\n        const si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() },\r\n            ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() },\r\n            dx = ti.x - si.x,\r\n            dy = ti.y - si.y,\r\n            l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\r\n        return {\r\n            sourceIntersection: si,\r\n            targetIntersection: ti,\r\n            arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the intersection of a line from the given point to the centre\r\n     * of the target rectangle where it intersects the rectanngle.\r\n     * @param [source] The source point.\r\n     * @param {Rectangle} [target] The target Rectangle.\r\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\r\n     *                      line by.\r\n     * @return The point an arrow head of the specified size would need to start.\r\n     */\r\n    export function makeEdgeTo(s: { x: number; y: number }, target: Rectangle, ah: number): Point {\r\n        var ti = target.rayIntersection(s.x, s.y);\r\n        if (!ti) ti = { x: target.cx(), y: target.cy() };\r\n        var dx = ti.x - s.x,\r\n            dy = ti.y - s.y,\r\n            l = Math.sqrt(dx * dx + dy * dy);\r\n        return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };\r\n    }\r\n\r\n    class Node {\r\n        prev: RBTree<Node>;\r\n        next: RBTree<Node>;\r\n\r\n        constructor(public v: Variable, public r: Rectangle, public pos: number) {\r\n            this.prev = makeRBTree();\r\n            this.next = makeRBTree();\r\n        }\r\n    }\r\n\r\n    class Event {\r\n        constructor(public isOpen: boolean, public v: Node, public pos: number) {}\r\n    }\r\n\r\n    function compareEvents(a: Event, b: Event): number {\r\n        if (a.pos > b.pos) {\r\n            return 1;\r\n        }\r\n        if (a.pos < b.pos) {\r\n            return -1;\r\n        }\r\n        if (a.isOpen) {\r\n            // open must come before close\r\n            return -1;\r\n        }\r\n        if (b.isOpen) {\r\n            // open must come before close\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function makeRBTree(): RBTree<Node> {\r\n        return new RBTree<Node>((a, b) => a.pos - b.pos);\r\n    }\r\n\r\n    interface RectAccessors {\r\n        getCentre: (r: Rectangle) => number;\r\n        getOpen: (r: Rectangle) => number;\r\n        getClose: (r: Rectangle) => number;\r\n        getSize: (r: Rectangle) => number;\r\n        makeRect: (open: number, close: number, center: number, size: number) => Rectangle;\r\n        findNeighbours: (v: Node, scanline: RBTree<Node>) => void;\r\n    }\r\n\r\n    var xRect: RectAccessors = {\r\n        getCentre: r=> r.cx(),\r\n        getOpen: r=> r.y,\r\n        getClose: r=> r.Y,\r\n        getSize: r=> r.width(),\r\n        makeRect: (open, close, center, size) => new Rectangle(center - size / 2, center + size / 2, open, close) ,\r\n        findNeighbours: findXNeighbours\r\n    };\r\n\r\n    var yRect: RectAccessors = {\r\n        getCentre: r=> r.cy(),\r\n        getOpen: r=> r.x,\r\n        getClose: r=> r.X,\r\n        getSize: r=> r.height(),\r\n        makeRect: (open, close, center, size) => new Rectangle(open, close, center - size / 2, center + size / 2),\r\n        findNeighbours: findYNeighbours\r\n    };\r\n\r\n    function generateGroupConstraints(root: ProjectionGroup, f: RectAccessors, minSep: number, isContained: boolean = false): Constraint[]\r\n    {\r\n        var padding = root.padding,\r\n            gn = typeof root.groups !== 'undefined' ? root.groups.length : 0,\r\n            ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0,\r\n            childConstraints: Constraint[] = !gn ? []\r\n            : root.groups.reduce((ccs: Constraint[], g) => ccs.concat(generateGroupConstraints(g, f, minSep, true)), []),\r\n            n = (isContained ? 2 : 0) + ln + gn,\r\n            vs: Variable[] = new Array(n),\r\n            rs: Rectangle[] = new Array(n),\r\n            i = 0,\r\n            add = (r, v) => { rs[i] = r; vs[i++] = v };\r\n        if (isContained) {\r\n            // if this group is contained by another, then we add two dummy vars and rectangles for the borders\r\n            var b: Rectangle = root.bounds,\r\n                c = f.getCentre(b), s = f.getSize(b) / 2,\r\n                open = f.getOpen(b), close = f.getClose(b),\r\n                min = c - s + padding / 2, max = c + s - padding / 2;\r\n            root.minVar.desiredPosition = min;\r\n            add(f.makeRect(open, close, min, padding), root.minVar);\r\n            root.maxVar.desiredPosition = max;\r\n            add(f.makeRect(open, close, max, padding), root.maxVar);\r\n        }\r\n        if (ln) root.leaves.forEach(l => add(l.bounds, l.variable));\r\n        if (gn) root.groups.forEach(g => {\r\n            var b: Rectangle = g.bounds;\r\n            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\r\n        });\r\n        var cs = generateConstraints(rs, vs, f, minSep);\r\n        if (gn) {\r\n            vs.forEach(v => { v.cOut = [], v.cIn = [] });\r\n            cs.forEach(c => { c.left.cOut.push(c), c.right.cIn.push(c) });\r\n            root.groups.forEach(g => {\r\n                var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\r\n                g.minVar.cIn.forEach(c => c.gap += gapAdjustment);\r\n                g.minVar.cOut.forEach(c => { c.left = g.maxVar; c.gap += gapAdjustment; });\r\n            });\r\n        }\r\n        return childConstraints.concat(cs);\r\n    }\r\n\r\n    function generateConstraints(rs: Rectangle[], vars: Variable[],\r\n        rect: RectAccessors, minSep: number): Constraint[]\r\n    {\r\n        var i, n = rs.length;\r\n        var N = 2 * n;\r\n        console.assert(vars.length >= n);\r\n        var events = new Array<Event>(N);\r\n        for (i = 0; i < n; ++i) {\r\n            var r = rs[i];\r\n            var v = new Node(vars[i], r, rect.getCentre(r));\r\n            events[i] = new Event(true, v, rect.getOpen(r));\r\n            events[i + n] = new Event(false, v, rect.getClose(r));\r\n        }\r\n        events.sort(compareEvents);\r\n        var cs = new Array<Constraint>();\r\n        var scanline = makeRBTree();\r\n        for (i = 0; i < N; ++i) {\r\n            var e = events[i];\r\n            var v = e.v;\r\n            if (e.isOpen) {\r\n                scanline.insert(v);\r\n                rect.findNeighbours(v, scanline);\r\n            } else {\r\n                // close event\r\n                scanline.remove(v);\r\n                var makeConstraint = (l, r) => {\r\n                    var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\r\n                    cs.push(new Constraint(l.v, r.v, sep));\r\n                };\r\n                var visitNeighbours = (forward, reverse, mkcon) => {\r\n                    var u, it = v[forward].iterator();\r\n                    while ((u = it[forward]()) !== null) {\r\n                        mkcon(u, v);\r\n                        u[reverse].remove(v);\r\n                    }\r\n                };\r\n                visitNeighbours(\"prev\", \"next\", (u, v) => makeConstraint(u, v));\r\n                visitNeighbours(\"next\", \"prev\", (u, v) => makeConstraint(v, u));\r\n            }\r\n        }\r\n        console.assert(scanline.size === 0);\r\n        return cs;\r\n    }\r\n\r\n    function findXNeighbours(v: Node, scanline: RBTree<Node>): void {\r\n        var f = (forward, reverse) => {\r\n            var it = scanline.findIter(v);\r\n            var u;\r\n            while ((u = it[forward]()) !== null) {\r\n                var uovervX = u.r.overlapX(v.r);\r\n                if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\r\n                    v[forward].insert(u);\r\n                    u[reverse].insert(v);\r\n                }\r\n                if (uovervX <= 0) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        f(\"next\", \"prev\");\r\n        f(\"prev\", \"next\");\r\n    }\r\n\r\n    function findYNeighbours(v: Node, scanline: RBTree<Node>): void {\r\n        var f = (forward, reverse) => {\r\n            var u = scanline.findIter(v)[forward]();\r\n            if (u !== null && u.r.overlapX(v.r) > 0) {\r\n                v[forward].insert(u);\r\n                u[reverse].insert(v);\r\n            }\r\n        }\r\n        f(\"next\", \"prev\");\r\n        f(\"prev\", \"next\");\r\n    }\r\n\r\n    export function generateXConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\r\n        return generateConstraints(rs, vars, xRect, 1e-6);\r\n    }\r\n\r\n    export function generateYConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\r\n        return generateConstraints(rs, vars, yRect, 1e-6);\r\n    }\r\n\r\n    export function generateXGroupConstraints(root: ProjectionGroup): Constraint[] {\r\n        return generateGroupConstraints(root, xRect, 1e-6);\r\n    }\r\n\r\n    export function generateYGroupConstraints(root: ProjectionGroup): Constraint[] {\r\n        return generateGroupConstraints(root, yRect, 1e-6);\r\n    }\r\n\r\n    export function removeOverlaps(rs: Rectangle[]): void {\r\n        var vs = rs.map(r => new Variable(r.cx()));\r\n        var cs = generateXConstraints(rs, vs);\r\n        var solver = new Solver(vs, cs);\r\n        solver.solve();\r\n        vs.forEach((v, i) => rs[i].setXCentre(v.position()));\r\n        vs = rs.map(r=> new Variable(r.cy()));\r\n        cs = generateYConstraints(rs, vs);\r\n        solver = new Solver(vs, cs);\r\n        solver.solve();\r\n        vs.forEach((v, i) => rs[i].setYCentre(v.position()));\r\n    }\r\n\r\n    export interface GraphNode extends Leaf {\r\n        fixed: boolean;\r\n        fixedWeight?: number;\r\n        width: number;\r\n        height: number;\r\n        x: number;\r\n        y: number;\r\n        px: number;\r\n        py: number;\r\n    }\r\n\r\n    export class IndexedVariable extends Variable {\r\n        constructor(public index: number, w: number) {\r\n            super(0, w);\r\n        }\r\n    }\r\n\r\n    export class Projection {\r\n        private xConstraints: Constraint[];\r\n        private yConstraints: Constraint[];\r\n        private variables: Variable[];\r\n\r\n        constructor(private nodes: GraphNode[],\r\n            private groups: ProjectionGroup[],\r\n            private rootGroup: ProjectionGroup = null,\r\n            constraints: any[]= null,\r\n            private avoidOverlaps: boolean = false)\r\n        {\r\n            this.variables = nodes.map((v, i) => {\r\n                return v.variable = new IndexedVariable(i, 1);\r\n            });\r\n\r\n            if (constraints) this.createConstraints(constraints);\r\n\r\n            if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\r\n                nodes.forEach(v => {\r\n\t\t\t\t\tif (!v.width || !v.height)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//If undefined, default to nothing\r\n\t\t\t\t\t\tv.bounds = new Rectangle(v.x, v.x, v.y, v.y);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n                    var w2 = v.width / 2, h2 = v.height / 2;\r\n                    v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\r\n                });\r\n                computeGroupBounds(rootGroup);\r\n                var i = nodes.length;\r\n                groups.forEach(g => {\r\n                    this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n                    this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n                });\r\n            }\r\n        }\r\n\r\n\r\n        private createSeparation(c: any) : Constraint {\r\n            return new Constraint(\r\n                this.nodes[c.left].variable,\r\n                this.nodes[c.right].variable,\r\n                c.gap,\r\n                typeof c.equality !== \"undefined\" ? c.equality : false);\r\n        }\r\n\r\n        // simple satisfaction of alignment constraints to ensure initial feasibility\r\n        private makeFeasible(c: any) {\r\n            if (!this.avoidOverlaps) return;\r\n            // sort nodes in constraint by position (along \"guideline\")\r\n            var axis = 'x', dim = 'width';\r\n            if (c.axis === 'x') axis = 'y', dim = 'height';\r\n            var vs: GraphNode[] = c.offsets.map(o => this.nodes[o.node]).sort((a, b) => a[axis] - b[axis]);\r\n            var p: GraphNode = null;\r\n            vs.forEach(v => {\r\n                // if two nodes overlap then shove the second one along\r\n                if (p) {\r\n                    let nextPos = p[axis] + p[dim];\r\n                    if (nextPos > v[axis]) {\r\n                        v[axis] = nextPos;\r\n                    }\r\n                }\r\n                p = v;\r\n            });\r\n        }\r\n\r\n        private createAlignment(c: any) {\r\n            var u = this.nodes[c.offsets[0].node].variable;\r\n            this.makeFeasible(c);\r\n            var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\r\n            c.offsets.slice(1).forEach(o => {\r\n                var v = this.nodes[o.node].variable;\r\n                cs.push(new Constraint(u, v, o.offset, true));\r\n            });\r\n        }\r\n\r\n        private createConstraints(constraints: any[]) {\r\n            var isSep = c => typeof c.type === 'undefined' || c.type === 'separation';\r\n            this.xConstraints = constraints\r\n                .filter(c => c.axis === \"x\" && isSep(c))\r\n                .map(c => this.createSeparation(c));\r\n            this.yConstraints = constraints\r\n                .filter(c => c.axis === \"y\" && isSep(c))\r\n                .map(c => this.createSeparation(c));\r\n            constraints\r\n                .filter(c => c.type === 'alignment')\r\n                .forEach(c => this.createAlignment(c));\r\n        }\r\n\r\n        private setupVariablesAndBounds(x0: number[], y0: number[], desired: number[], getDesired: (v: GraphNode) => number) {\r\n            this.nodes.forEach((v, i) => {\r\n                if (v.fixed) {\r\n                    v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\r\n                    desired[i] = getDesired(v);\r\n                } else {\r\n                    v.variable.weight = 1;\r\n                }\r\n                var w = (v.width || 0) / 2, h = (v.height || 0) / 2;\r\n                var ix = x0[i], iy = y0[i];\r\n                v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\r\n            });\r\n        }\r\n\r\n        xProject(x0: number[], y0: number[], x: number[]) {\r\n            if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints)) return;\r\n            this.project(x0, y0, x0, x, v=> v.px, this.xConstraints, generateXGroupConstraints,\r\n                v => v.bounds.setXCentre(x[(<IndexedVariable>v.variable).index] = v.variable.position()),\r\n                g => {\r\n                    var xmin = x[(<IndexedVariable>g.minVar).index] = g.minVar.position();\r\n                    var xmax = x[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\r\n                    var p2 = g.padding / 2;\r\n                    g.bounds.x = xmin - p2;\r\n                    g.bounds.X = xmax + p2;\r\n                });\r\n        }\r\n\r\n        yProject(x0: number[], y0: number[], y: number[]) {\r\n            if (!this.rootGroup && !this.yConstraints) return;\r\n            this.project(x0, y0, y0, y, v=> v.py, this.yConstraints, generateYGroupConstraints,\r\n                v => v.bounds.setYCentre(y[(<IndexedVariable>v.variable).index] = v.variable.position()),\r\n                g => {\r\n                    var ymin = y[(<IndexedVariable>g.minVar).index] = g.minVar.position();\r\n                    var ymax = y[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\r\n                    var p2 = g.padding / 2;\r\n                    g.bounds.y = ymin - p2;;\r\n                    g.bounds.Y = ymax + p2;\r\n                });\r\n        }\r\n\r\n        projectFunctions(): { (x0: number[], y0: number[], r: number[]): void }[]{\r\n            return [\r\n                (x0, y0, x) => this.xProject(x0, y0, x),\r\n                (x0, y0, y) => this.yProject(x0, y0, y)\r\n            ];\r\n        }\r\n\r\n        private project(x0: number[], y0: number[], start: number[], desired: number[],\r\n            getDesired: (v: GraphNode) => number,\r\n            cs: Constraint[],\r\n            generateConstraints: (g: ProjectionGroup) => Constraint[],\r\n            updateNodeBounds: (v: GraphNode) => any,\r\n            updateGroupBounds: (g: ProjectionGroup) => any)\r\n        {\r\n            this.setupVariablesAndBounds(x0, y0, desired, getDesired);\r\n            if (this.rootGroup && this.avoidOverlaps) {\r\n                computeGroupBounds(this.rootGroup);\r\n                cs = cs.concat(generateConstraints(this.rootGroup));\r\n            }\r\n            this.solve(this.variables, cs, start, desired);\r\n            this.nodes.forEach(updateNodeBounds);\r\n            if (this.rootGroup && this.avoidOverlaps) {\r\n                this.groups.forEach(updateGroupBounds);\r\n                computeGroupBounds(this.rootGroup);\r\n            }\r\n        }\r\n\r\n        private solve(vs: Variable[], cs: Constraint[], starting: number[], desired: number[]) {\r\n            var solver = new Solver(vs, cs);\r\n            solver.setStartingPositions(starting);\r\n            solver.setDesiredPositions(desired);\r\n            solver.solve();\r\n        }\r\n    }\r\n"]}},"hash":"abdc0ed050ddeacef0023a790168f449","cacheData":{"env":{}}}