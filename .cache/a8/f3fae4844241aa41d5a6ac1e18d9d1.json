{"id":"node_modules/webcola/dist/src/handledisconnected.js","dependencies":[{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/handledisconnected.js.map","includedInParent":true,"mtime":1517462217000},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/WebCola/src/handledisconnected.ts","includedInParent":true,"mtime":1516884256000},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/package.json","includedInParent":true,"mtime":1550967406043},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/package.json","includedInParent":true,"mtime":1550967405642}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar packingOptions = {\r\n    PADDING: 10,\r\n    GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,\r\n    FLOAT_EPSILON: 0.0001,\r\n    MAX_INERATIONS: 100\r\n};\r\nfunction applyPacking(graphs, w, h, node_size, desired_ratio) {\r\n    if (desired_ratio === void 0) { desired_ratio = 1; }\r\n    var init_x = 0, init_y = 0, svg_width = w, svg_height = h, desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1, node_size = typeof node_size !== 'undefined' ? node_size : 0, real_width = 0, real_height = 0, min_width = 0, global_bottom = 0, line = [];\r\n    if (graphs.length == 0)\r\n        return;\r\n    calculate_bb(graphs);\r\n    apply(graphs, desired_ratio);\r\n    put_nodes_to_right_positions(graphs);\r\n    function calculate_bb(graphs) {\r\n        graphs.forEach(function (g) {\r\n            calculate_single_bb(g);\r\n        });\r\n        function calculate_single_bb(graph) {\r\n            var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_x = 0, max_y = 0;\r\n            graph.array.forEach(function (v) {\r\n                var w = typeof v.width !== 'undefined' ? v.width : node_size;\r\n                var h = typeof v.height !== 'undefined' ? v.height : node_size;\r\n                w /= 2;\r\n                h /= 2;\r\n                max_x = Math.max(v.x + w, max_x);\r\n                min_x = Math.min(v.x - w, min_x);\r\n                max_y = Math.max(v.y + h, max_y);\r\n                min_y = Math.min(v.y - h, min_y);\r\n            });\r\n            graph.width = max_x - min_x;\r\n            graph.height = max_y - min_y;\r\n        }\r\n    }\r\n    function put_nodes_to_right_positions(graphs) {\r\n        graphs.forEach(function (g) {\r\n            var center = { x: 0, y: 0 };\r\n            g.array.forEach(function (node) {\r\n                center.x += node.x;\r\n                center.y += node.y;\r\n            });\r\n            center.x /= g.array.length;\r\n            center.y /= g.array.length;\r\n            var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };\r\n            var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2 };\r\n            g.array.forEach(function (node) {\r\n                node.x += offset.x;\r\n                node.y += offset.y;\r\n            });\r\n        });\r\n    }\r\n    function apply(data, desired_ratio) {\r\n        var curr_best_f = Number.POSITIVE_INFINITY;\r\n        var curr_best = 0;\r\n        data.sort(function (a, b) { return b.height - a.height; });\r\n        min_width = data.reduce(function (a, b) {\r\n            return a.width < b.width ? a.width : b.width;\r\n        });\r\n        var left = x1 = min_width;\r\n        var right = x2 = get_entire_width(data);\r\n        var iterationCounter = 0;\r\n        var f_x1 = Number.MAX_VALUE;\r\n        var f_x2 = Number.MAX_VALUE;\r\n        var flag = -1;\r\n        var dx = Number.MAX_VALUE;\r\n        var df = Number.MAX_VALUE;\r\n        while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {\r\n            if (flag != 1) {\r\n                var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;\r\n                var f_x1 = step(data, x1);\r\n            }\r\n            if (flag != 0) {\r\n                var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;\r\n                var f_x2 = step(data, x2);\r\n            }\r\n            dx = Math.abs(x1 - x2);\r\n            df = Math.abs(f_x1 - f_x2);\r\n            if (f_x1 < curr_best_f) {\r\n                curr_best_f = f_x1;\r\n                curr_best = x1;\r\n            }\r\n            if (f_x2 < curr_best_f) {\r\n                curr_best_f = f_x2;\r\n                curr_best = x2;\r\n            }\r\n            if (f_x1 > f_x2) {\r\n                left = x1;\r\n                x1 = x2;\r\n                f_x1 = f_x2;\r\n                flag = 1;\r\n            }\r\n            else {\r\n                right = x2;\r\n                x2 = x1;\r\n                f_x2 = f_x1;\r\n                flag = 0;\r\n            }\r\n            if (iterationCounter++ > 100) {\r\n                break;\r\n            }\r\n        }\r\n        step(data, curr_best);\r\n    }\r\n    function step(data, max_width) {\r\n        line = [];\r\n        real_width = 0;\r\n        real_height = 0;\r\n        global_bottom = init_y;\r\n        for (var i = 0; i < data.length; i++) {\r\n            var o = data[i];\r\n            put_rect(o, max_width);\r\n        }\r\n        return Math.abs(get_real_ratio() - desired_ratio);\r\n    }\r\n    function put_rect(rect, max_width) {\r\n        var parent = undefined;\r\n        for (var i = 0; i < line.length; i++) {\r\n            if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {\r\n                parent = line[i];\r\n                break;\r\n            }\r\n        }\r\n        line.push(rect);\r\n        if (parent !== undefined) {\r\n            rect.x = parent.x + parent.width + packingOptions.PADDING;\r\n            rect.y = parent.bottom;\r\n            rect.space_left = rect.height;\r\n            rect.bottom = rect.y;\r\n            parent.space_left -= rect.height + packingOptions.PADDING;\r\n            parent.bottom += rect.height + packingOptions.PADDING;\r\n        }\r\n        else {\r\n            rect.y = global_bottom;\r\n            global_bottom += rect.height + packingOptions.PADDING;\r\n            rect.x = init_x;\r\n            rect.bottom = rect.y;\r\n            rect.space_left = rect.height;\r\n        }\r\n        if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON)\r\n            real_height = rect.y + rect.height - init_y;\r\n        if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON)\r\n            real_width = rect.x + rect.width - init_x;\r\n    }\r\n    ;\r\n    function get_entire_width(data) {\r\n        var width = 0;\r\n        data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });\r\n        return width;\r\n    }\r\n    function get_real_ratio() {\r\n        return (real_width / real_height);\r\n    }\r\n}\r\nexports.applyPacking = applyPacking;\r\nfunction separateGraphs(nodes, links) {\r\n    var marks = {};\r\n    var ways = {};\r\n    var graphs = [];\r\n    var clusters = 0;\r\n    for (var i = 0; i < links.length; i++) {\r\n        var link = links[i];\r\n        var n1 = link.source;\r\n        var n2 = link.target;\r\n        if (ways[n1.index])\r\n            ways[n1.index].push(n2);\r\n        else\r\n            ways[n1.index] = [n2];\r\n        if (ways[n2.index])\r\n            ways[n2.index].push(n1);\r\n        else\r\n            ways[n2.index] = [n1];\r\n    }\r\n    for (var i = 0; i < nodes.length; i++) {\r\n        var node = nodes[i];\r\n        if (marks[node.index])\r\n            continue;\r\n        explore_node(node, true);\r\n    }\r\n    function explore_node(n, is_new) {\r\n        if (marks[n.index] !== undefined)\r\n            return;\r\n        if (is_new) {\r\n            clusters++;\r\n            graphs.push({ array: [] });\r\n        }\r\n        marks[n.index] = clusters;\r\n        graphs[clusters - 1].array.push(n);\r\n        var adjacent = ways[n.index];\r\n        if (!adjacent)\r\n            return;\r\n        for (var j = 0; j < adjacent.length; j++) {\r\n            explore_node(adjacent[j], false);\r\n        }\r\n    }\r\n    return graphs;\r\n}\r\nexports.separateGraphs = separateGraphs;\r\n","map":{"version":3,"file":"handledisconnected.js","sourceRoot":"","sources":["../../WebCola/src/handledisconnected.ts"],"names":[],"mappings":"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","sourcesContent":["    var packingOptions = {\r\n        PADDING: 10,\r\n        GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,\r\n        FLOAT_EPSILON: 0.0001,\r\n        MAX_INERATIONS: 100\r\n    };\r\n\r\n    // assign x, y to nodes while using box packing algorithm for disconnected graphs\r\n    export function applyPacking(graphs:Array<any>, w, h, node_size, desired_ratio = 1) {\r\n\r\n        var init_x = 0,\r\n            init_y = 0,\r\n\r\n            svg_width = w,\r\n            svg_height = h,\r\n\r\n            desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1,\r\n            node_size = typeof node_size !== 'undefined' ? node_size : 0,\r\n\r\n            real_width = 0,\r\n            real_height = 0,\r\n            min_width = 0,\r\n\r\n            global_bottom = 0,\r\n            line = [];\r\n\r\n        if (graphs.length == 0)\r\n            return;\r\n\r\n        /// that would take care of single nodes problem\r\n        // graphs.forEach(function (g) {\r\n        //     if (g.array.length == 1) {\r\n        //         g.array[0].x = 0;\r\n        //         g.array[0].y = 0;\r\n        //     }\r\n        // });\r\n\r\n        calculate_bb(graphs);\r\n        apply(graphs, desired_ratio);\r\n        put_nodes_to_right_positions(graphs);\r\n\r\n        // get bounding boxes for all separate graphs\r\n        function calculate_bb(graphs) {\r\n\r\n            graphs.forEach(function (g) {\r\n                calculate_single_bb(g)\r\n            });\r\n\r\n            function calculate_single_bb(graph) {\r\n                var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE,\r\n                    max_x = 0, max_y = 0;\r\n\r\n                graph.array.forEach(function (v) {\r\n                    var w = typeof v.width !== 'undefined' ? v.width : node_size;\r\n                    var h = typeof v.height !== 'undefined' ? v.height : node_size;\r\n                    w /= 2;\r\n                    h /= 2;\r\n                    max_x = Math.max(v.x + w, max_x);\r\n                    min_x = Math.min(v.x - w, min_x);\r\n                    max_y = Math.max(v.y + h, max_y);\r\n                    min_y = Math.min(v.y - h, min_y);\r\n                });\r\n\r\n                graph.width = max_x - min_x;\r\n                graph.height = max_y - min_y;\r\n            }\r\n        }\r\n\r\n        //function plot(data, left, right, opt_x, opt_y) {\r\n        //    // plot the cost function\r\n        //    var plot_svg = d3.select(\"body\").append(\"svg\")\r\n        //        .attr(\"width\", function () { return 2 * (right - left); })\r\n        //        .attr(\"height\", 200);\r\n\r\n\r\n        //    var x = d3.time.scale().range([0, 2 * (right - left)]);\r\n\r\n        //    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\");\r\n        //    plot_svg.append(\"g\").attr(\"class\", \"x axis\")\r\n        //        .attr(\"transform\", \"translate(0, 199)\")\r\n        //        .call(xAxis);\r\n\r\n        //    var lastX = 0;\r\n        //    var lastY = 0;\r\n        //    var value = 0;\r\n        //    for (var r = left; r < right; r += 1) {\r\n        //        value = step(data, r);\r\n        //        // value = 1;\r\n\r\n        //        plot_svg.append(\"line\").attr(\"x1\", 2 * (lastX - left))\r\n        //            .attr(\"y1\", 200 - 30 * lastY)\r\n        //            .attr(\"x2\", 2 * r - 2 * left)\r\n        //            .attr(\"y2\", 200 - 30 * value)\r\n        //            .style(\"stroke\", \"rgb(6,120,155)\");\r\n\r\n        //        lastX = r;\r\n        //        lastY = value;\r\n        //    }\r\n\r\n        //    plot_svg.append(\"circle\").attr(\"cx\", 2 * opt_x - 2 * left).attr(\"cy\", 200 - 30 * opt_y)\r\n        //        .attr(\"r\", 5).style('fill', \"rgba(0,0,0,0.5)\");\r\n\r\n        //}\r\n\r\n        // actual assigning of position to nodes\r\n        function put_nodes_to_right_positions(graphs) {\r\n            graphs.forEach(function (g) {\r\n                // calculate current graph center:\r\n                var center = { x: 0, y: 0 };\r\n\r\n                g.array.forEach(function (node) {\r\n                    center.x += node.x;\r\n                    center.y += node.y;\r\n                });\r\n\r\n                center.x /= g.array.length;\r\n                center.y /= g.array.length;\r\n\r\n                // calculate current top left corner:\r\n                var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };\r\n                var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2};\r\n\r\n                // put nodes:\r\n                g.array.forEach(function (node) {\r\n                    node.x += offset.x;\r\n                    node.y += offset.y;\r\n                });\r\n            });\r\n        }\r\n\r\n        // starts box packing algorithm\r\n        // desired ratio is 1 by default\r\n        function apply(data, desired_ratio) {\r\n            var curr_best_f = Number.POSITIVE_INFINITY;\r\n            var curr_best = 0;\r\n            data.sort(function (a, b) { return b.height - a.height; });\r\n\r\n            min_width = data.reduce(function (a, b) {\r\n                return a.width < b.width ? a.width : b.width;\r\n            });\r\n\r\n            var left = x1 = min_width;\r\n            var right = x2 = get_entire_width(data);\r\n            var iterationCounter = 0;\r\n\r\n            var f_x1 = Number.MAX_VALUE;\r\n            var f_x2 = Number.MAX_VALUE;\r\n            var flag = -1; // determines which among f_x1 and f_x2 to recompute\r\n\r\n\r\n            var dx = Number.MAX_VALUE;\r\n            var df = Number.MAX_VALUE;\r\n\r\n            while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {\r\n\r\n                if (flag != 1) {\r\n                    var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;\r\n                    var f_x1 = step(data, x1);\r\n                }\r\n                if (flag != 0) {\r\n                    var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;\r\n                    var f_x2 = step(data, x2);\r\n                }\r\n\r\n                dx = Math.abs(x1 - x2);\r\n                df = Math.abs(f_x1 - f_x2);\r\n\r\n                if (f_x1 < curr_best_f) {\r\n                    curr_best_f = f_x1;\r\n                    curr_best = x1;\r\n                }\r\n\r\n                if (f_x2 < curr_best_f) {\r\n                    curr_best_f = f_x2;\r\n                    curr_best = x2;\r\n                }\r\n\r\n                if (f_x1 > f_x2) {\r\n                    left = x1;\r\n                    x1 = x2;\r\n                    f_x1 = f_x2;\r\n                    flag = 1;\r\n                } else {\r\n                    right = x2;\r\n                    x2 = x1;\r\n                    f_x2 = f_x1;\r\n                    flag = 0;\r\n                }\r\n\r\n                if (iterationCounter++ > 100) {\r\n                    break;\r\n                }\r\n            }\r\n            // plot(data, min_width, get_entire_width(data), curr_best, curr_best_f);\r\n            step(data, curr_best);\r\n        }\r\n\r\n        // one iteration of the optimization method\r\n        // (gives a proper, but not necessarily optimal packing)\r\n        function step(data, max_width) {\r\n            line = [];\r\n            real_width = 0;\r\n            real_height = 0;\r\n            global_bottom = init_y;\r\n\r\n            for (var i = 0; i < data.length; i++) {\r\n                var o = data[i];\r\n                put_rect(o, max_width);\r\n            }\r\n\r\n            return Math.abs(get_real_ratio() - desired_ratio);\r\n        }\r\n\r\n        // looking for a position to one box\r\n        function put_rect(rect, max_width) {\r\n\r\n\r\n            var parent = undefined;\r\n\r\n            for (var i = 0; i < line.length; i++) {\r\n                if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {\r\n                    parent = line[i];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            line.push(rect);\r\n\r\n            if (parent !== undefined) {\r\n                rect.x = parent.x + parent.width + packingOptions.PADDING;\r\n                rect.y = parent.bottom;\r\n                rect.space_left = rect.height;\r\n                rect.bottom = rect.y;\r\n                parent.space_left -= rect.height + packingOptions.PADDING;\r\n                parent.bottom += rect.height + packingOptions.PADDING;\r\n            } else {\r\n                rect.y = global_bottom;\r\n                global_bottom += rect.height + packingOptions.PADDING;\r\n                rect.x = init_x;\r\n                rect.bottom = rect.y;\r\n                rect.space_left = rect.height;\r\n            }\r\n\r\n            if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON) real_height = rect.y + rect.height - init_y;\r\n            if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON) real_width = rect.x + rect.width - init_x;\r\n        };\r\n\r\n        function get_entire_width(data) {\r\n            var width = 0;\r\n            data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });\r\n            return width;\r\n        }\r\n\r\n        function get_real_ratio() {\r\n            return (real_width / real_height);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * connected components of graph\r\n     * returns an array of {}\r\n     */\r\n    export function separateGraphs(nodes, links) {\r\n        var marks = {};\r\n        var ways = {};\r\n        var graphs = [];\r\n        var clusters = 0;\r\n\r\n        for (var i = 0; i < links.length; i++) {\r\n            var link = links[i];\r\n            var n1 = link.source;\r\n            var n2 = link.target;\r\n            if (ways[n1.index])\r\n                ways[n1.index].push(n2);\r\n            else\r\n                ways[n1.index] = [n2];\r\n\r\n            if (ways[n2.index])\r\n                ways[n2.index].push(n1);\r\n            else\r\n                ways[n2.index] = [n1];\r\n        }\r\n\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            var node = nodes[i];\r\n            if (marks[node.index]) continue;\r\n            explore_node(node, true);\r\n        }\r\n\r\n        function explore_node(n, is_new) {\r\n            if (marks[n.index] !== undefined) return;\r\n            if (is_new) {\r\n                clusters++;\r\n                graphs.push({ array: [] });\r\n            }\r\n            marks[n.index] = clusters;\r\n            graphs[clusters - 1].array.push(n);\r\n            var adjacent = ways[n.index];\r\n            if (!adjacent) return;\r\n\r\n            for (var j = 0; j < adjacent.length; j++) {\r\n                explore_node(adjacent[j], false);\r\n            }\r\n        }\r\n\r\n        return graphs;\r\n    }\r\n"]}},"hash":"9e251af6c9383557e979a42f671dda56","cacheData":{"env":{}}}