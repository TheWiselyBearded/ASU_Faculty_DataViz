{"id":"node_modules/webcola/dist/src/linklengths.js","dependencies":[{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/linklengths.js.map","includedInParent":true,"mtime":1517462217000},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/WebCola/src/linklengths.ts","includedInParent":true,"mtime":1516884256000},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/package.json","includedInParent":true,"mtime":1550967406043},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/package.json","includedInParent":true,"mtime":1550967405642}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction unionCount(a, b) {\r\n    var u = {};\r\n    for (var i in a)\r\n        u[i] = {};\r\n    for (var i in b)\r\n        u[i] = {};\r\n    return Object.keys(u).length;\r\n}\r\nfunction intersectionCount(a, b) {\r\n    var n = 0;\r\n    for (var i in a)\r\n        if (typeof b[i] !== 'undefined')\r\n            ++n;\r\n    return n;\r\n}\r\nfunction getNeighbours(links, la) {\r\n    var neighbours = {};\r\n    var addNeighbours = function (u, v) {\r\n        if (typeof neighbours[u] === 'undefined')\r\n            neighbours[u] = {};\r\n        neighbours[u][v] = {};\r\n    };\r\n    links.forEach(function (e) {\r\n        var u = la.getSourceIndex(e), v = la.getTargetIndex(e);\r\n        addNeighbours(u, v);\r\n        addNeighbours(v, u);\r\n    });\r\n    return neighbours;\r\n}\r\nfunction computeLinkLengths(links, w, f, la) {\r\n    var neighbours = getNeighbours(links, la);\r\n    links.forEach(function (l) {\r\n        var a = neighbours[la.getSourceIndex(l)];\r\n        var b = neighbours[la.getTargetIndex(l)];\r\n        la.setLength(l, 1 + w * f(a, b));\r\n    });\r\n}\r\nfunction symmetricDiffLinkLengths(links, la, w) {\r\n    if (w === void 0) { w = 1; }\r\n    computeLinkLengths(links, w, function (a, b) { return Math.sqrt(unionCount(a, b) - intersectionCount(a, b)); }, la);\r\n}\r\nexports.symmetricDiffLinkLengths = symmetricDiffLinkLengths;\r\nfunction jaccardLinkLengths(links, la, w) {\r\n    if (w === void 0) { w = 1; }\r\n    computeLinkLengths(links, w, function (a, b) {\r\n        return Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b);\r\n    }, la);\r\n}\r\nexports.jaccardLinkLengths = jaccardLinkLengths;\r\nfunction generateDirectedEdgeConstraints(n, links, axis, la) {\r\n    var components = stronglyConnectedComponents(n, links, la);\r\n    var nodes = {};\r\n    components.forEach(function (c, i) {\r\n        return c.forEach(function (v) { return nodes[v] = i; });\r\n    });\r\n    var constraints = [];\r\n    links.forEach(function (l) {\r\n        var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l), u = nodes[ui], v = nodes[vi];\r\n        if (u !== v) {\r\n            constraints.push({\r\n                axis: axis,\r\n                left: ui,\r\n                right: vi,\r\n                gap: la.getMinSeparation(l)\r\n            });\r\n        }\r\n    });\r\n    return constraints;\r\n}\r\nexports.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;\r\nfunction stronglyConnectedComponents(numVertices, edges, la) {\r\n    var nodes = [];\r\n    var index = 0;\r\n    var stack = [];\r\n    var components = [];\r\n    function strongConnect(v) {\r\n        v.index = v.lowlink = index++;\r\n        stack.push(v);\r\n        v.onStack = true;\r\n        for (var _i = 0, _a = v.out; _i < _a.length; _i++) {\r\n            var w = _a[_i];\r\n            if (typeof w.index === 'undefined') {\r\n                strongConnect(w);\r\n                v.lowlink = Math.min(v.lowlink, w.lowlink);\r\n            }\r\n            else if (w.onStack) {\r\n                v.lowlink = Math.min(v.lowlink, w.index);\r\n            }\r\n        }\r\n        if (v.lowlink === v.index) {\r\n            var component = [];\r\n            while (stack.length) {\r\n                w = stack.pop();\r\n                w.onStack = false;\r\n                component.push(w);\r\n                if (w === v)\r\n                    break;\r\n            }\r\n            components.push(component.map(function (v) { return v.id; }));\r\n        }\r\n    }\r\n    for (var i = 0; i < numVertices; i++) {\r\n        nodes.push({ id: i, out: [] });\r\n    }\r\n    for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {\r\n        var e = edges_1[_i];\r\n        var v_1 = nodes[la.getSourceIndex(e)], w = nodes[la.getTargetIndex(e)];\r\n        v_1.out.push(w);\r\n    }\r\n    for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {\r\n        var v = nodes_1[_a];\r\n        if (typeof v.index === 'undefined')\r\n            strongConnect(v);\r\n    }\r\n    return components;\r\n}\r\nexports.stronglyConnectedComponents = stronglyConnectedComponents;\r\n","map":{"version":3,"file":"linklengths.js","sourceRoot":"","sources":["../../WebCola/src/linklengths.ts"],"names":[],"mappings":"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","sourcesContent":["    export interface LinkAccessor<Link> {\r\n        getSourceIndex(l: Link): number;\r\n        getTargetIndex(l: Link): number;\r\n    }\r\n\r\n    export interface LinkLengthAccessor<Link> extends LinkAccessor<Link> {\r\n        setLength(l: Link, value: number): void;\r\n    }\r\n\r\n    // compute the size of the union of two sets a and b\r\n    function unionCount(a: any, b: any): number {\r\n        var u = {};\r\n        for (var i in a) u[i] = {};\r\n        for (var i in b) u[i] = {};\r\n        return Object.keys(u).length;\r\n    }\r\n\r\n    // compute the size of the intersection of two sets a and b\r\n    function intersectionCount(a: number[], b: number[]): number {\r\n        var n = 0;\r\n        for (var i in a) if (typeof b[i] !== 'undefined') ++n;\r\n        return n;\r\n    }\r\n\r\n    function getNeighbours<Link>(links: Link[], la: LinkAccessor<Link>): any {\r\n        var neighbours = {};\r\n        var addNeighbours = (u, v) => {\r\n            if (typeof neighbours[u] === 'undefined')\r\n                neighbours[u] = {};\r\n            neighbours[u][v] = {};\r\n        };\r\n        links.forEach(e => {\r\n            var u = la.getSourceIndex(e), v = la.getTargetIndex(e);\r\n            addNeighbours(u, v);\r\n            addNeighbours(v, u);\r\n        });\r\n        return neighbours;\r\n    }\r\n\r\n    // modify the lengths of the specified links by the result of function f weighted by w\r\n    function computeLinkLengths<Link>(links: Link[], w: number, f: (a: any, b: any) => number, la: LinkLengthAccessor<Link>) {\r\n        var neighbours = getNeighbours(links, la);\r\n        links.forEach(l => {\r\n            var a = neighbours[la.getSourceIndex(l)];\r\n            var b = neighbours[la.getTargetIndex(l)];\r\n            la.setLength(l, 1 + w * f(a, b));\r\n        });\r\n    }\r\n\r\n    /** modify the specified link lengths based on the symmetric difference of their neighbours\r\n     * @class symmetricDiffLinkLengths\r\n     */\r\n    export function symmetricDiffLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\r\n        computeLinkLengths(links, w, (a, b) => Math.sqrt(unionCount(a, b) - intersectionCount(a, b)), la);\r\n    }\r\n\r\n    /** modify the specified links lengths based on the jaccard difference between their neighbours\r\n     * @class jaccardLinkLengths\r\n     */\r\n    export function jaccardLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\r\n        computeLinkLengths(links, w, (a, b) =>\r\n            Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b)\r\n            , la);\r\n    }\r\n\r\n    export interface IConstraint {\r\n        left: number;\r\n        right: number;\r\n        gap: number;\r\n    }\r\n\r\n    export interface DirectedEdgeConstraints {\r\n        axis: string;\r\n        gap: number;\r\n    }\r\n\r\n    export interface LinkSepAccessor<Link> extends LinkAccessor<Link> {\r\n        getMinSeparation(l: Link): number;\r\n    }\r\n\r\n    /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component\r\n     * @class generateDirectedEdgeConstraints\r\n     */\r\n    export function generateDirectedEdgeConstraints<Link>(n: number, links: Link[], axis: string,\r\n        la: LinkSepAccessor<Link>): IConstraint[]\r\n    {\r\n        var components = stronglyConnectedComponents(n, links, la);\r\n        var nodes = {};\r\n        components.forEach((c,i) =>\r\n            c.forEach(v => nodes[v] = i)\r\n        );\r\n        var constraints: any[] = [];\r\n        links.forEach(l => {\r\n            var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l),\r\n                u = nodes[ui], v = nodes[vi];\r\n            if (u !== v) {\r\n                constraints.push({\r\n                    axis: axis,\r\n                    left: ui,\r\n                    right: vi,\r\n                    gap: la.getMinSeparation(l)\r\n                });\r\n            }\r\n        });\r\n        return constraints;\r\n    }\r\n\r\n    /**\r\n     * Tarjan's strongly connected components algorithm for directed graphs\r\n     * returns an array of arrays of node indicies in each of the strongly connected components.\r\n     * a vertex not in a SCC of two or more nodes is it's own SCC.\r\n     * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n     */\r\n    export function stronglyConnectedComponents<Link>(numVertices: number, edges: Link[], la: LinkAccessor<Link>): number[][]{\r\n        var nodes = [];\r\n        var index = 0;\r\n        var stack = [];\r\n        var components = [];\r\n        function strongConnect(v) {\r\n            // Set the depth index for v to the smallest unused index\r\n            v.index = v.lowlink = index++;\r\n            stack.push(v);\r\n            v.onStack = true;\r\n\r\n            // Consider successors of v\r\n            for (var w of v.out) {\r\n                if (typeof w.index === 'undefined') {\r\n                    // Successor w has not yet been visited; recurse on it\r\n                    strongConnect(w);\r\n                    v.lowlink = Math.min(v.lowlink, w.lowlink);\r\n                } else if (w.onStack) {\r\n                    // Successor w is in stack S and hence in the current SCC\r\n                    v.lowlink = Math.min(v.lowlink, w.index);\r\n                }\r\n            }\r\n\r\n            // If v is a root node, pop the stack and generate an SCC\r\n            if (v.lowlink === v.index) {\r\n                // start a new strongly connected component\r\n                var component = [];\r\n                while (stack.length) {\r\n                    w = stack.pop();\r\n                    w.onStack = false;\r\n                    //add w to current strongly connected component\r\n                    component.push(w);\r\n                    if (w === v) break;\r\n                }\r\n                // output the current strongly connected component\r\n                components.push(component.map(v => v.id));\r\n            }\r\n        }\r\n        for (var i = 0; i < numVertices; i++) {\r\n            nodes.push({id: i, out: []});\r\n        }\r\n        for (var e of edges) {\r\n            let v = nodes[la.getSourceIndex(e)],\r\n                w = nodes[la.getTargetIndex(e)];\r\n            v.out.push(w);\r\n        }\r\n        for (var v of nodes) if (typeof v.index === 'undefined') strongConnect(v);\r\n        return components;\r\n    }\r\n"]}},"hash":"871e80bd3b9e14f4a99951112cea2905","cacheData":{"env":{}}}