{"id":"node_modules/webcola/dist/src/gridrouter.js","dependencies":[{"name":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/dist/src/gridrouter.js.map","includedInParent":true,"mtime":1517462217000},{"name":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/WebCola/src/gridrouter.ts","includedInParent":true,"mtime":1516884256000},{"name":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/package.json","includedInParent":true,"mtime":1550967406043},{"name":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/package.json","includedInParent":true,"mtime":1550967405642},{"name":"./rectangle","loc":{"line":3,"column":26},"parent":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/dist/src/gridrouter.js","resolved":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/dist/src/rectangle.js"},{"name":"./vpsc","loc":{"line":4,"column":21},"parent":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/dist/src/gridrouter.js","resolved":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/dist/src/vpsc.js"},{"name":"./shortestpaths","loc":{"line":5,"column":30},"parent":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/dist/src/gridrouter.js","resolved":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/dist/src/shortestpaths.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar rectangle_1 = require(\"./rectangle\");\r\nvar vpsc_1 = require(\"./vpsc\");\r\nvar shortestpaths_1 = require(\"./shortestpaths\");\r\nvar NodeWrapper = (function () {\r\n    function NodeWrapper(id, rect, children) {\r\n        this.id = id;\r\n        this.rect = rect;\r\n        this.children = children;\r\n        this.leaf = typeof children === 'undefined' || children.length === 0;\r\n    }\r\n    return NodeWrapper;\r\n}());\r\nexports.NodeWrapper = NodeWrapper;\r\nvar Vert = (function () {\r\n    function Vert(id, x, y, node, line) {\r\n        if (node === void 0) { node = null; }\r\n        if (line === void 0) { line = null; }\r\n        this.id = id;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.node = node;\r\n        this.line = line;\r\n    }\r\n    return Vert;\r\n}());\r\nexports.Vert = Vert;\r\nvar LongestCommonSubsequence = (function () {\r\n    function LongestCommonSubsequence(s, t) {\r\n        this.s = s;\r\n        this.t = t;\r\n        var mf = LongestCommonSubsequence.findMatch(s, t);\r\n        var tr = t.slice(0).reverse();\r\n        var mr = LongestCommonSubsequence.findMatch(s, tr);\r\n        if (mf.length >= mr.length) {\r\n            this.length = mf.length;\r\n            this.si = mf.si;\r\n            this.ti = mf.ti;\r\n            this.reversed = false;\r\n        }\r\n        else {\r\n            this.length = mr.length;\r\n            this.si = mr.si;\r\n            this.ti = t.length - mr.ti - mr.length;\r\n            this.reversed = true;\r\n        }\r\n    }\r\n    LongestCommonSubsequence.findMatch = function (s, t) {\r\n        var m = s.length;\r\n        var n = t.length;\r\n        var match = { length: 0, si: -1, ti: -1 };\r\n        var l = new Array(m);\r\n        for (var i = 0; i < m; i++) {\r\n            l[i] = new Array(n);\r\n            for (var j = 0; j < n; j++)\r\n                if (s[i] === t[j]) {\r\n                    var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;\r\n                    if (v > match.length) {\r\n                        match.length = v;\r\n                        match.si = i - v + 1;\r\n                        match.ti = j - v + 1;\r\n                    }\r\n                    ;\r\n                }\r\n                else\r\n                    l[i][j] = 0;\r\n        }\r\n        return match;\r\n    };\r\n    LongestCommonSubsequence.prototype.getSequence = function () {\r\n        return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\r\n    };\r\n    return LongestCommonSubsequence;\r\n}());\r\nexports.LongestCommonSubsequence = LongestCommonSubsequence;\r\nvar GridRouter = (function () {\r\n    function GridRouter(originalnodes, accessor, groupPadding) {\r\n        if (groupPadding === void 0) { groupPadding = 12; }\r\n        var _this = this;\r\n        this.originalnodes = originalnodes;\r\n        this.groupPadding = groupPadding;\r\n        this.leaves = null;\r\n        this.nodes = originalnodes.map(function (v, i) { return new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)); });\r\n        this.leaves = this.nodes.filter(function (v) { return v.leaf; });\r\n        this.groups = this.nodes.filter(function (g) { return !g.leaf; });\r\n        this.cols = this.getGridLines('x');\r\n        this.rows = this.getGridLines('y');\r\n        this.groups.forEach(function (v) {\r\n            return v.children.forEach(function (c) { return _this.nodes[c].parent = v; });\r\n        });\r\n        this.root = { children: [] };\r\n        this.nodes.forEach(function (v) {\r\n            if (typeof v.parent === 'undefined') {\r\n                v.parent = _this.root;\r\n                _this.root.children.push(v.id);\r\n            }\r\n            v.ports = [];\r\n        });\r\n        this.backToFront = this.nodes.slice(0);\r\n        this.backToFront.sort(function (x, y) { return _this.getDepth(x) - _this.getDepth(y); });\r\n        var frontToBackGroups = this.backToFront.slice(0).reverse().filter(function (g) { return !g.leaf; });\r\n        frontToBackGroups.forEach(function (v) {\r\n            var r = rectangle_1.Rectangle.empty();\r\n            v.children.forEach(function (c) { return r = r.union(_this.nodes[c].rect); });\r\n            v.rect = r.inflate(_this.groupPadding);\r\n        });\r\n        var colMids = this.midPoints(this.cols.map(function (r) { return r.pos; }));\r\n        var rowMids = this.midPoints(this.rows.map(function (r) { return r.pos; }));\r\n        var rowx = colMids[0], rowX = colMids[colMids.length - 1];\r\n        var coly = rowMids[0], colY = rowMids[rowMids.length - 1];\r\n        var hlines = this.rows.map(function (r) { return ({ x1: rowx, x2: rowX, y1: r.pos, y2: r.pos }); })\r\n            .concat(rowMids.map(function (m) { return ({ x1: rowx, x2: rowX, y1: m, y2: m }); }));\r\n        var vlines = this.cols.map(function (c) { return ({ x1: c.pos, x2: c.pos, y1: coly, y2: colY }); })\r\n            .concat(colMids.map(function (m) { return ({ x1: m, x2: m, y1: coly, y2: colY }); }));\r\n        var lines = hlines.concat(vlines);\r\n        lines.forEach(function (l) { return l.verts = []; });\r\n        this.verts = [];\r\n        this.edges = [];\r\n        hlines.forEach(function (h) {\r\n            return vlines.forEach(function (v) {\r\n                var p = new Vert(_this.verts.length, v.x1, h.y1);\r\n                h.verts.push(p);\r\n                v.verts.push(p);\r\n                _this.verts.push(p);\r\n                var i = _this.backToFront.length;\r\n                while (i-- > 0) {\r\n                    var node = _this.backToFront[i], r = node.rect;\r\n                    var dx = Math.abs(p.x - r.cx()), dy = Math.abs(p.y - r.cy());\r\n                    if (dx < r.width() / 2 && dy < r.height() / 2) {\r\n                        p.node = node;\r\n                        break;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        lines.forEach(function (l, li) {\r\n            _this.nodes.forEach(function (v, i) {\r\n                v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach(function (intersect, j) {\r\n                    var p = new Vert(_this.verts.length, intersect.x, intersect.y, v, l);\r\n                    _this.verts.push(p);\r\n                    l.verts.push(p);\r\n                    v.ports.push(p);\r\n                });\r\n            });\r\n            var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\r\n            var delta = function (a, b) { return isHoriz ? b.x - a.x : b.y - a.y; };\r\n            l.verts.sort(delta);\r\n            for (var i = 1; i < l.verts.length; i++) {\r\n                var u = l.verts[i - 1], v = l.verts[i];\r\n                if (u.node && u.node === v.node && u.node.leaf)\r\n                    continue;\r\n                _this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });\r\n            }\r\n        });\r\n    }\r\n    GridRouter.prototype.avg = function (a) { return a.reduce(function (x, y) { return x + y; }) / a.length; };\r\n    GridRouter.prototype.getGridLines = function (axis) {\r\n        var columns = [];\r\n        var ls = this.leaves.slice(0, this.leaves.length);\r\n        while (ls.length > 0) {\r\n            var overlapping = ls.filter(function (v) { return v.rect['overlap' + axis.toUpperCase()](ls[0].rect); });\r\n            var col = {\r\n                nodes: overlapping,\r\n                pos: this.avg(overlapping.map(function (v) { return v.rect['c' + axis](); }))\r\n            };\r\n            columns.push(col);\r\n            col.nodes.forEach(function (v) { return ls.splice(ls.indexOf(v), 1); });\r\n        }\r\n        columns.sort(function (a, b) { return a.pos - b.pos; });\r\n        return columns;\r\n    };\r\n    GridRouter.prototype.getDepth = function (v) {\r\n        var depth = 0;\r\n        while (v.parent !== this.root) {\r\n            depth++;\r\n            v = v.parent;\r\n        }\r\n        return depth;\r\n    };\r\n    GridRouter.prototype.midPoints = function (a) {\r\n        var gap = a[1] - a[0];\r\n        var mids = [a[0] - gap / 2];\r\n        for (var i = 1; i < a.length; i++) {\r\n            mids.push((a[i] + a[i - 1]) / 2);\r\n        }\r\n        mids.push(a[a.length - 1] + gap / 2);\r\n        return mids;\r\n    };\r\n    GridRouter.prototype.findLineage = function (v) {\r\n        var lineage = [v];\r\n        do {\r\n            v = v.parent;\r\n            lineage.push(v);\r\n        } while (v !== this.root);\r\n        return lineage.reverse();\r\n    };\r\n    GridRouter.prototype.findAncestorPathBetween = function (a, b) {\r\n        var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;\r\n        while (aa[i] === ba[i])\r\n            i++;\r\n        return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };\r\n    };\r\n    GridRouter.prototype.siblingObstacles = function (a, b) {\r\n        var _this = this;\r\n        var path = this.findAncestorPathBetween(a, b);\r\n        var lineageLookup = {};\r\n        path.lineages.forEach(function (v) { return lineageLookup[v.id] = {}; });\r\n        var obstacles = path.commonAncestor.children.filter(function (v) { return !(v in lineageLookup); });\r\n        path.lineages\r\n            .filter(function (v) { return v.parent !== path.commonAncestor; })\r\n            .forEach(function (v) { return obstacles = obstacles.concat(v.parent.children.filter(function (c) { return c !== v.id; })); });\r\n        return obstacles.map(function (v) { return _this.nodes[v]; });\r\n    };\r\n    GridRouter.getSegmentSets = function (routes, x, y) {\r\n        var vsegments = [];\r\n        for (var ei = 0; ei < routes.length; ei++) {\r\n            var route = routes[ei];\r\n            for (var si = 0; si < route.length; si++) {\r\n                var s = route[si];\r\n                s.edgeid = ei;\r\n                s.i = si;\r\n                var sdx = s[1][x] - s[0][x];\r\n                if (Math.abs(sdx) < 0.1) {\r\n                    vsegments.push(s);\r\n                }\r\n            }\r\n        }\r\n        vsegments.sort(function (a, b) { return a[0][x] - b[0][x]; });\r\n        var vsegmentsets = [];\r\n        var segmentset = null;\r\n        for (var i = 0; i < vsegments.length; i++) {\r\n            var s = vsegments[i];\r\n            if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\r\n                segmentset = { pos: s[0][x], segments: [] };\r\n                vsegmentsets.push(segmentset);\r\n            }\r\n            segmentset.segments.push(s);\r\n        }\r\n        return vsegmentsets;\r\n    };\r\n    GridRouter.nudgeSegs = function (x, y, routes, segments, leftOf, gap) {\r\n        var n = segments.length;\r\n        if (n <= 1)\r\n            return;\r\n        var vs = segments.map(function (s) { return new vpsc_1.Variable(s[0][x]); });\r\n        var cs = [];\r\n        for (var i = 0; i < n; i++) {\r\n            for (var j = 0; j < n; j++) {\r\n                if (i === j)\r\n                    continue;\r\n                var s1 = segments[i], s2 = segments[j], e1 = s1.edgeid, e2 = s2.edgeid, lind = -1, rind = -1;\r\n                if (x == 'x') {\r\n                    if (leftOf(e1, e2)) {\r\n                        if (s1[0][y] < s1[1][y]) {\r\n                            lind = j, rind = i;\r\n                        }\r\n                        else {\r\n                            lind = i, rind = j;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (leftOf(e1, e2)) {\r\n                        if (s1[0][y] < s1[1][y]) {\r\n                            lind = i, rind = j;\r\n                        }\r\n                        else {\r\n                            lind = j, rind = i;\r\n                        }\r\n                    }\r\n                }\r\n                if (lind >= 0) {\r\n                    cs.push(new vpsc_1.Constraint(vs[lind], vs[rind], gap));\r\n                }\r\n            }\r\n        }\r\n        var solver = new vpsc_1.Solver(vs, cs);\r\n        solver.solve();\r\n        vs.forEach(function (v, i) {\r\n            var s = segments[i];\r\n            var pos = v.position();\r\n            s[0][x] = s[1][x] = pos;\r\n            var route = routes[s.edgeid];\r\n            if (s.i > 0)\r\n                route[s.i - 1][1][x] = pos;\r\n            if (s.i < route.length - 1)\r\n                route[s.i + 1][0][x] = pos;\r\n        });\r\n    };\r\n    GridRouter.nudgeSegments = function (routes, x, y, leftOf, gap) {\r\n        var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\r\n        for (var i = 0; i < vsegmentsets.length; i++) {\r\n            var ss = vsegmentsets[i];\r\n            var events = [];\r\n            for (var j = 0; j < ss.segments.length; j++) {\r\n                var s = ss.segments[j];\r\n                events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });\r\n                events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });\r\n            }\r\n            events.sort(function (a, b) { return a.pos - b.pos + a.type - b.type; });\r\n            var open = [];\r\n            var openCount = 0;\r\n            events.forEach(function (e) {\r\n                if (e.type === 0) {\r\n                    open.push(e.s);\r\n                    openCount++;\r\n                }\r\n                else {\r\n                    openCount--;\r\n                }\r\n                if (openCount == 0) {\r\n                    GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\r\n                    open = [];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    GridRouter.prototype.routeEdges = function (edges, nudgeGap, source, target) {\r\n        var _this = this;\r\n        var routePaths = edges.map(function (e) { return _this.route(source(e), target(e)); });\r\n        var order = GridRouter.orderEdges(routePaths);\r\n        var routes = routePaths.map(function (e) { return GridRouter.makeSegments(e); });\r\n        GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\r\n        GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\r\n        GridRouter.unreverseEdges(routes, routePaths);\r\n        return routes;\r\n    };\r\n    GridRouter.unreverseEdges = function (routes, routePaths) {\r\n        routes.forEach(function (segments, i) {\r\n            var path = routePaths[i];\r\n            if (path.reversed) {\r\n                segments.reverse();\r\n                segments.forEach(function (segment) {\r\n                    segment.reverse();\r\n                });\r\n            }\r\n        });\r\n    };\r\n    GridRouter.angleBetween2Lines = function (line1, line2) {\r\n        var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);\r\n        var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);\r\n        var diff = angle1 - angle2;\r\n        if (diff > Math.PI || diff < -Math.PI) {\r\n            diff = angle2 - angle1;\r\n        }\r\n        return diff;\r\n    };\r\n    GridRouter.isLeft = function (a, b, c) {\r\n        return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;\r\n    };\r\n    GridRouter.getOrder = function (pairs) {\r\n        var outgoing = {};\r\n        for (var i = 0; i < pairs.length; i++) {\r\n            var p = pairs[i];\r\n            if (typeof outgoing[p.l] === 'undefined')\r\n                outgoing[p.l] = {};\r\n            outgoing[p.l][p.r] = true;\r\n        }\r\n        return function (l, r) { return typeof outgoing[l] !== 'undefined' && outgoing[l][r]; };\r\n    };\r\n    GridRouter.orderEdges = function (edges) {\r\n        var edgeOrder = [];\r\n        for (var i = 0; i < edges.length - 1; i++) {\r\n            for (var j = i + 1; j < edges.length; j++) {\r\n                var e = edges[i], f = edges[j], lcs = new LongestCommonSubsequence(e, f);\r\n                var u, vi, vj;\r\n                if (lcs.length === 0)\r\n                    continue;\r\n                if (lcs.reversed) {\r\n                    f.reverse();\r\n                    f.reversed = true;\r\n                    lcs = new LongestCommonSubsequence(e, f);\r\n                }\r\n                if ((lcs.si <= 0 || lcs.ti <= 0) &&\r\n                    (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\r\n                    edgeOrder.push({ l: i, r: j });\r\n                    continue;\r\n                }\r\n                if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\r\n                    u = e[lcs.si + 1];\r\n                    vj = e[lcs.si - 1];\r\n                    vi = f[lcs.ti - 1];\r\n                }\r\n                else {\r\n                    u = e[lcs.si + lcs.length - 2];\r\n                    vi = e[lcs.si + lcs.length];\r\n                    vj = f[lcs.ti + lcs.length];\r\n                }\r\n                if (GridRouter.isLeft(u, vi, vj)) {\r\n                    edgeOrder.push({ l: j, r: i });\r\n                }\r\n                else {\r\n                    edgeOrder.push({ l: i, r: j });\r\n                }\r\n            }\r\n        }\r\n        return GridRouter.getOrder(edgeOrder);\r\n    };\r\n    GridRouter.makeSegments = function (path) {\r\n        function copyPoint(p) {\r\n            return { x: p.x, y: p.y };\r\n        }\r\n        var isStraight = function (a, b, c) { return Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001; };\r\n        var segments = [];\r\n        var a = copyPoint(path[0]);\r\n        for (var i = 1; i < path.length; i++) {\r\n            var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;\r\n            if (!c || !isStraight(a, b, c)) {\r\n                segments.push([a, b]);\r\n                a = b;\r\n            }\r\n        }\r\n        return segments;\r\n    };\r\n    GridRouter.prototype.route = function (s, t) {\r\n        var _this = this;\r\n        var source = this.nodes[s], target = this.nodes[t];\r\n        this.obstacles = this.siblingObstacles(source, target);\r\n        var obstacleLookup = {};\r\n        this.obstacles.forEach(function (o) { return obstacleLookup[o.id] = o; });\r\n        this.passableEdges = this.edges.filter(function (e) {\r\n            var u = _this.verts[e.source], v = _this.verts[e.target];\r\n            return !(u.node && u.node.id in obstacleLookup\r\n                || v.node && v.node.id in obstacleLookup);\r\n        });\r\n        for (var i = 1; i < source.ports.length; i++) {\r\n            var u = source.ports[0].id;\r\n            var v = source.ports[i].id;\r\n            this.passableEdges.push({\r\n                source: u,\r\n                target: v,\r\n                length: 0\r\n            });\r\n        }\r\n        for (var i = 1; i < target.ports.length; i++) {\r\n            var u = target.ports[0].id;\r\n            var v = target.ports[i].id;\r\n            this.passableEdges.push({\r\n                source: u,\r\n                target: v,\r\n                length: 0\r\n            });\r\n        }\r\n        var getSource = function (e) { return e.source; }, getTarget = function (e) { return e.target; }, getLength = function (e) { return e.length; };\r\n        var shortestPathCalculator = new shortestpaths_1.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\r\n        var bendPenalty = function (u, v, w) {\r\n            var a = _this.verts[u], b = _this.verts[v], c = _this.verts[w];\r\n            var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);\r\n            if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)\r\n                return 0;\r\n            return dx > 1 && dy > 1 ? 1000 : 0;\r\n        };\r\n        var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);\r\n        var pathPoints = shortestPath.reverse().map(function (vi) { return _this.verts[vi]; });\r\n        pathPoints.push(this.nodes[target.id].ports[0]);\r\n        return pathPoints.filter(function (v, i) {\r\n            return !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source\r\n                || i > 0 && v.node === target && pathPoints[i - 1].node === target);\r\n        });\r\n    };\r\n    GridRouter.getRoutePath = function (route, cornerradius, arrowwidth, arrowheight) {\r\n        var result = {\r\n            routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\r\n            arrowpath: ''\r\n        };\r\n        if (route.length > 1) {\r\n            for (var i = 0; i < route.length; i++) {\r\n                var li = route[i];\r\n                var x = li[1].x, y = li[1].y;\r\n                var dx = x - li[0].x;\r\n                var dy = y - li[0].y;\r\n                if (i < route.length - 1) {\r\n                    if (Math.abs(dx) > 0) {\r\n                        x -= dx / Math.abs(dx) * cornerradius;\r\n                    }\r\n                    else {\r\n                        y -= dy / Math.abs(dy) * cornerradius;\r\n                    }\r\n                    result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                    var l = route[i + 1];\r\n                    var x0 = l[0].x, y0 = l[0].y;\r\n                    var x1 = l[1].x;\r\n                    var y1 = l[1].y;\r\n                    dx = x1 - x0;\r\n                    dy = y1 - y0;\r\n                    var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\r\n                    var x2, y2;\r\n                    if (Math.abs(dx) > 0) {\r\n                        x2 = x0 + dx / Math.abs(dx) * cornerradius;\r\n                        y2 = y0;\r\n                    }\r\n                    else {\r\n                        x2 = x0;\r\n                        y2 = y0 + dy / Math.abs(dy) * cornerradius;\r\n                    }\r\n                    var cx = Math.abs(x2 - x);\r\n                    var cy = Math.abs(y2 - y);\r\n                    result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\r\n                }\r\n                else {\r\n                    var arrowtip = [x, y];\r\n                    var arrowcorner1, arrowcorner2;\r\n                    if (Math.abs(dx) > 0) {\r\n                        x -= dx / Math.abs(dx) * arrowheight;\r\n                        arrowcorner1 = [x, y + arrowwidth];\r\n                        arrowcorner2 = [x, y - arrowwidth];\r\n                    }\r\n                    else {\r\n                        y -= dy / Math.abs(dy) * arrowheight;\r\n                        arrowcorner1 = [x + arrowwidth, y];\r\n                        arrowcorner2 = [x - arrowwidth, y];\r\n                    }\r\n                    result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                    if (arrowheight > 0) {\r\n                        result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                            + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var li = route[0];\r\n            var x = li[1].x, y = li[1].y;\r\n            var dx = x - li[0].x;\r\n            var dy = y - li[0].y;\r\n            var arrowtip = [x, y];\r\n            var arrowcorner1, arrowcorner2;\r\n            if (Math.abs(dx) > 0) {\r\n                x -= dx / Math.abs(dx) * arrowheight;\r\n                arrowcorner1 = [x, y + arrowwidth];\r\n                arrowcorner2 = [x, y - arrowwidth];\r\n            }\r\n            else {\r\n                y -= dy / Math.abs(dy) * arrowheight;\r\n                arrowcorner1 = [x + arrowwidth, y];\r\n                arrowcorner2 = [x - arrowwidth, y];\r\n            }\r\n            result.routepath += 'L ' + x + ' ' + y + ' ';\r\n            if (arrowheight > 0) {\r\n                result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                    + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    return GridRouter;\r\n}());\r\nexports.GridRouter = GridRouter;\r\n","map":{"version":3,"file":"gridrouter.js","sourceRoot":"","sources":["../../WebCola/src/gridrouter.ts"],"names":[],"mappings":"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","sourcesContent":["import {Point} from './geom'\r\nimport {Rectangle} from './rectangle'\r\nimport {Constraint, Solver, Variable} from './vpsc'\r\nimport {Calculator} from './shortestpaths'\r\n    export interface NodeAccessor<Node>{\r\n        getChildren(v:Node) : number[];\r\n        getBounds(v:Node) : Rectangle;\r\n    }\r\n    export class NodeWrapper {\r\n        leaf: boolean;\r\n        parent: NodeWrapper;\r\n        ports: Vert[];\r\n        constructor(public id: number, public rect: Rectangle, public children: number[]) {\r\n            this.leaf = typeof children === 'undefined' || children.length === 0;\r\n        }\r\n    }\r\n    export class Vert {\r\n        constructor(public id: number, public x:number, public y: number, public node: NodeWrapper = null, public line = null) {}\r\n    }\r\n\r\n    export class LongestCommonSubsequence<T> {\r\n        length: number;\r\n        si: number;\r\n        ti: number;\r\n        reversed: boolean;\r\n        constructor(public s: T[], public t: T[]) {\r\n            var mf = LongestCommonSubsequence.findMatch(s, t);\r\n            var tr = t.slice(0).reverse();\r\n            var mr = LongestCommonSubsequence.findMatch(s, tr);\r\n            if (mf.length >= mr.length) {\r\n                this.length = mf.length;\r\n                this.si = mf.si;\r\n                this.ti = mf.ti;\r\n                this.reversed = false;\r\n            } else {\r\n                this.length = mr.length;\r\n                this.si = mr.si;\r\n                this.ti = t.length - mr.ti - mr.length;\r\n                this.reversed = true;\r\n            }\r\n        }\r\n        private static findMatch<T>(s: T[], t: T[]) {\r\n            var m = s.length;\r\n            var n = t.length;\r\n            var match = { length: 0, si: -1, ti: -1 };\r\n            var l = new Array(m);\r\n            for (var i = 0; i < m; i++) {\r\n                l[i] = new Array(n);\r\n                for (var j = 0; j < n; j++)\r\n                    if (s[i] === t[j]) {\r\n                        var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;\r\n                        if (v > match.length) {\r\n                            match.length = v;\r\n                            match.si = i - v + 1;\r\n                            match.ti = j - v + 1;\r\n                        };\r\n                    } else l[i][j] = 0;\r\n            }\r\n            return match;\r\n        }\r\n        getSequence(): T[]{\r\n            return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\r\n        }\r\n    }\r\n    // a horizontal or vertical line of nodes\r\n    export interface GridLine {\r\n        nodes: NodeWrapper[];\r\n        pos: number;\r\n    }\r\n    export class GridRouter<Node> {\r\n        leaves: NodeWrapper[] = null;\r\n        groups: NodeWrapper[];\r\n        nodes: NodeWrapper[];\r\n        cols: GridLine[];\r\n        rows: GridLine[];\r\n        root;\r\n        verts: Vert[];\r\n        edges;\r\n        backToFront;\r\n        obstacles;\r\n        passableEdges;\r\n        private avg(a) { return a.reduce((x, y) => x + y) / a.length }\r\n\r\n        // in the given axis, find sets of leaves overlapping in that axis\r\n        // center of each GridLine is average of all nodes in column\r\n        private getGridLines(axis): GridLine[] {\r\n            var columns = [];\r\n            var ls = this.leaves.slice(0, this.leaves.length);\r\n            while (ls.length > 0) {\r\n                // find a column of all leaves overlapping in axis with the first leaf\r\n                let overlapping = ls.filter(v=> v.rect['overlap' + axis.toUpperCase()](ls[0].rect));\r\n                let col = {\r\n                    nodes: overlapping,\r\n                    pos: this.avg(overlapping.map(v=> v.rect['c' + axis]()))\r\n                };\r\n                columns.push(col);\r\n                col.nodes.forEach(v=> ls.splice(ls.indexOf(v), 1));\r\n            }\r\n            columns.sort((a, b) => a.pos - b.pos)\r\n            return columns;\r\n        }\r\n\r\n        // get the depth of the given node in the group hierarchy\r\n        private getDepth(v) {\r\n            var depth = 0;\r\n            while (v.parent !== this.root) {\r\n                depth++;\r\n                v = v.parent;\r\n            }\r\n            return depth;\r\n        }\r\n\r\n        // medial axes between node centres and also boundary lines for the grid\r\n        private midPoints(a) {\r\n            var gap = a[1] - a[0];\r\n            var mids = [a[0] - gap / 2];\r\n            for (var i = 1; i < a.length; i++) {\r\n                mids.push((a[i] + a[i - 1]) / 2);\r\n            }\r\n            mids.push(a[a.length - 1] + gap / 2);\r\n            return mids;\r\n        }\r\n\r\n        constructor(public originalnodes: Node[], accessor: NodeAccessor<Node>, public groupPadding: number = 12) {\r\n            this.nodes = originalnodes.map((v, i) => new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)));\r\n            this.leaves = this.nodes.filter(v=> v.leaf);\r\n            this.groups = this.nodes.filter(g=> !g.leaf);\r\n            this.cols = this.getGridLines('x');\r\n            this.rows = this.getGridLines('y');\r\n\r\n            // create parents for each node or group that is a member of another's children\r\n            this.groups.forEach(v=>\r\n                v.children.forEach(c=> this.nodes[<number>c].parent = v));\r\n\r\n            // root claims the remaining orphans\r\n            this.root = { children: [] };\r\n            this.nodes.forEach(v=> {\r\n                if (typeof v.parent === 'undefined') {\r\n                    v.parent = this.root;\r\n                    this.root.children.push(v.id);\r\n                }\r\n\r\n                // each node will have grid vertices associated with it,\r\n                // some inside the node and some on the boundary\r\n                // leaf nodes will have exactly one internal node at the center\r\n                // and four boundary nodes\r\n                // groups will have potentially many of each\r\n                v.ports = []\r\n            });\r\n\r\n            // nodes ordered by their position in the group hierarchy\r\n            this.backToFront = this.nodes.slice(0);\r\n            this.backToFront.sort((x, y) => this.getDepth(x) - this.getDepth(y));\r\n\r\n            // compute boundary rectangles for each group\r\n            // has to be done from front to back, i.e. inside groups to outside groups\r\n            // such that each can be made large enough to enclose its interior\r\n            var frontToBackGroups = this.backToFront.slice(0).reverse().filter(g=> !g.leaf);\r\n            frontToBackGroups.forEach(v=> {\r\n                var r = Rectangle.empty();\r\n                v.children.forEach(c=> r = r.union(this.nodes[c].rect));\r\n                v.rect = r.inflate(this.groupPadding);\r\n            });\r\n\r\n            var colMids = this.midPoints(this.cols.map(r=> r.pos));\r\n            var rowMids = this.midPoints(this.rows.map(r=> r.pos));\r\n\r\n            // setup extents of lines\r\n            var rowx = colMids[0], rowX = colMids[colMids.length - 1];\r\n            var coly = rowMids[0], colY = rowMids[rowMids.length - 1];\r\n\r\n            // horizontal lines\r\n            var hlines = this.rows.map(r=> <any>{ x1: rowx, x2: rowX, y1: r.pos, y2: r.pos })\r\n                .concat(rowMids.map(m=> <any>{ x1: rowx, x2: rowX, y1: m, y2: m }));\r\n\r\n            // vertical lines\r\n            var vlines = this.cols.map(c=> <any>{ x1: c.pos, x2: c.pos, y1: coly, y2: colY })\r\n                .concat(colMids.map(m=> <any>{ x1: m, x2: m, y1: coly, y2: colY }));\r\n\r\n            // the full set of lines\r\n            var lines = hlines.concat(vlines);\r\n\r\n            // we record the vertices associated with each line\r\n            lines.forEach(l=> l.verts = []);\r\n\r\n            // the routing graph\r\n            this.verts = [];\r\n            this.edges = [];\r\n\r\n            // create vertices at the crossings of horizontal and vertical grid-lines\r\n            hlines.forEach(h=>\r\n                vlines.forEach(v=> {\r\n                    var p = new Vert(this.verts.length, v.x1, h.y1);\r\n                    h.verts.push(p);\r\n                    v.verts.push(p);\r\n                    this.verts.push(p);\r\n\r\n                    // assign vertices to the nodes immediately under them\r\n                    var i = this.backToFront.length;\r\n                    while (i-- > 0) {\r\n                        var node = this.backToFront[i],\r\n                            r = node.rect;\r\n                        var dx = Math.abs(p.x - r.cx()),\r\n                            dy = Math.abs(p.y - r.cy());\r\n                        if (dx < r.width() / 2 && dy < r.height() / 2) {\r\n                            (<any>p).node = node;\r\n                            break;\r\n                        }\r\n                    }\r\n                })\r\n                );\r\n\r\n            lines.forEach((l, li) => {\r\n                // create vertices at the intersections of nodes and lines\r\n                this.nodes.forEach((v, i) => {\r\n                    v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach((intersect, j) => {\r\n                        //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);\r\n                        var p = new Vert(this.verts.length, intersect.x, intersect.y, v, l);\r\n                        this.verts.push(p);\r\n                        l.verts.push(p);\r\n                        v.ports.push(p);\r\n                    });\r\n                });\r\n\r\n                // split lines into edges joining vertices\r\n                var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\r\n                var delta = (a, b) => isHoriz ? b.x - a.x : b.y - a.y;\r\n                l.verts.sort(delta);\r\n                for (var i = 1; i < l.verts.length; i++) {\r\n                    var u = l.verts[i - 1], v = l.verts[i];\r\n                    if (u.node && u.node === v.node && u.node.leaf) continue;\r\n                    this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });\r\n                }\r\n            });\r\n\r\n\r\n\r\n        }\r\n\r\n        // find path from v to root including both v and root\r\n        private findLineage(v) {\r\n            var lineage = [v];\r\n            do {\r\n                v = v.parent;\r\n                lineage.push(v);\r\n            } while (v !== this.root);\r\n            return lineage.reverse();\r\n        }\r\n\r\n        // find path connecting a and b through their lowest common ancestor\r\n        private findAncestorPathBetween(a, b) {\r\n            var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;\r\n            while (aa[i] === ba[i]) i++;\r\n            // i-1 to include common ancestor only once (as first element)\r\n            return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };\r\n        }\r\n\r\n        // when finding a path between two nodes a and b, siblings of a and b on the\r\n        // paths from a and b to their least common ancestor are obstacles\r\n        siblingObstacles(a, b) {\r\n            var path = this.findAncestorPathBetween(a, b);\r\n            var lineageLookup = {};\r\n            path.lineages.forEach(v=> lineageLookup[v.id] = {});\r\n            var obstacles = path.commonAncestor.children.filter(v=> !(v in lineageLookup));\r\n\r\n            path.lineages\r\n                .filter(v=> v.parent !== path.commonAncestor)\r\n                .forEach(v=> obstacles = obstacles.concat(v.parent.children.filter(c=> c !== v.id)));\r\n\r\n            return obstacles.map(v=> this.nodes[v]);\r\n        }\r\n\r\n        // for the given routes, extract all the segments orthogonal to the axis x\r\n        // and return all them grouped by x position\r\n        static getSegmentSets(routes, x, y) {\r\n            // vsegments is a list of vertical segments sorted by x position\r\n            var vsegments = [];\r\n            for (var ei = 0; ei < routes.length; ei++) {\r\n                var route = routes[ei];\r\n                for (var si = 0; si < route.length; si++) {\r\n                    var s = <any>route[si];\r\n                    s.edgeid = ei;\r\n                    s.i = si;\r\n                    var sdx = s[1][x] - s[0][x];\r\n                    if (Math.abs(sdx) < 0.1) {\r\n                        vsegments.push(s);\r\n                    }\r\n                }\r\n            }\r\n            vsegments.sort((a, b) => a[0][x] - b[0][x]);\r\n\r\n            // vsegmentsets is a set of sets of segments grouped by x position\r\n            var vsegmentsets = [];\r\n            var segmentset = null;\r\n            for (var i = 0; i < vsegments.length; i++) {\r\n                var s = vsegments[i];\r\n                if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\r\n                    segmentset = { pos: s[0][x], segments: [] };\r\n                    vsegmentsets.push(segmentset);\r\n                }\r\n                segmentset.segments.push(s);\r\n            }\r\n            return vsegmentsets;\r\n        }\r\n\r\n        // for all segments in this bundle create a vpsc problem such that\r\n        // each segment's x position is a variable and separation constraints\r\n        // are given by the partial order over the edges to which the segments belong\r\n        // for each pair s1,s2 of segments in the open set:\r\n        //   e1 = edge of s1, e2 = edge of s2\r\n        //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x\r\n        //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x\r\n        static nudgeSegs(x: string, y: string, routes, segments, leftOf, gap: number) {\r\n            var n = segments.length;\r\n            if (n <= 1) return;\r\n            var vs = segments.map(s => new Variable(s[0][x]));\r\n            var cs = [];\r\n            for (var i = 0; i < n; i++) {\r\n                for (var j = 0; j < n; j++) {\r\n                    if (i === j) continue;\r\n                    var s1 = segments[i],\r\n                        s2 = segments[j],\r\n                        e1 = s1.edgeid,\r\n                        e2 = s2.edgeid,\r\n                        lind = -1,\r\n                        rind = -1;\r\n                    // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis\r\n                    // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the\r\n                    // 'left' edge actually needs to be nudged to the right\r\n                    // when nudging horizontal segments, if the segments increase in the x direction\r\n                    // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right\r\n                    if (x == 'x') {\r\n                        if (leftOf(e1, e2)) {\r\n                            //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);\r\n                            if (s1[0][y] < s1[1][y]) {\r\n                                lind = j, rind = i;\r\n                            } else {\r\n                                lind = i, rind = j;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (leftOf(e1, e2)) {\r\n                            if (s1[0][y] < s1[1][y]) {\r\n                                lind = i, rind = j;\r\n                            } else {\r\n                                lind = j, rind = i;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (lind >= 0) {\r\n                        //console.log(x+' constraint: ' + lind + '<' + rind);\r\n                        cs.push(new Constraint(vs[lind], vs[rind], gap));\r\n                    }\r\n                }\r\n            }\r\n            var solver = new Solver(vs, cs);\r\n            solver.solve();\r\n            vs.forEach((v, i) => {\r\n                var s = segments[i];\r\n                var pos = v.position();\r\n                s[0][x] = s[1][x] = pos;\r\n                var route = routes[s.edgeid];\r\n                if (s.i > 0) route[s.i - 1][1][x] = pos;\r\n                if (s.i < route.length - 1) route[s.i + 1][0][x] = pos;\r\n            });\r\n        }\r\n\r\n        static nudgeSegments(routes, x: string, y: string, leftOf: (e1: number, e2: number) => boolean, gap: number) {\r\n            var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\r\n            // scan the grouped (by x) segment sets to find co-linear bundles\r\n            for (var i = 0; i < vsegmentsets.length; i++) {\r\n                var ss = vsegmentsets[i];\r\n                var events = [];\r\n                for (var j = 0; j < ss.segments.length; j++) {\r\n                    var s = ss.segments[j];\r\n                    events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });\r\n                    events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });\r\n                }\r\n                events.sort((a, b) => a.pos - b.pos + a.type - b.type);\r\n                var open = [];\r\n                var openCount = 0;\r\n                events.forEach(e=> {\r\n                    if (e.type === 0) {\r\n                        open.push(e.s);\r\n                        openCount++;\r\n                    } else {\r\n                        openCount--;\r\n                    }\r\n                    if (openCount == 0) {\r\n                        GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\r\n                        open = [];\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        // obtain routes for the specified edges, nicely nudged apart\r\n        // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!\r\n        // @param edges list of edges\r\n        // @param nudgeGap how much to space parallel edge segements\r\n        // @param source function to retrieve the index of the source node for a given edge\r\n        // @param target function to retrieve the index of the target node for a given edge\r\n        // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array\r\n        routeEdges<Edge>(edges: Edge[], nudgeGap: number, source: (e: Edge) => number, target: (e: Edge) => number): Point[][][] {\r\n            var routePaths = edges.map(e=> this.route(source(e), target(e)));\r\n            var order = GridRouter.orderEdges(routePaths);\r\n            var routes = routePaths.map(function (e) { return GridRouter.makeSegments(e); });\r\n            GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\r\n            GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\r\n            GridRouter.unreverseEdges(routes, routePaths);\r\n            return routes;\r\n        }\r\n\r\n        // path may have been reversed by the subsequence processing in orderEdges\r\n        // so now we need to restore the original order\r\n        static unreverseEdges(routes, routePaths) {\r\n            routes.forEach((segments, i) => {\r\n                var path = routePaths[i];\r\n                if ((<any>path).reversed) {\r\n                    segments.reverse(); // reverse order of segments\r\n                    segments.forEach(function (segment) {\r\n                        segment.reverse();  // reverse each segment\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        static angleBetween2Lines(line1: Point[], line2: Point[]): number {\r\n            var angle1 = Math.atan2(line1[0].y - line1[1].y,\r\n                line1[0].x - line1[1].x);\r\n            var angle2 = Math.atan2(line2[0].y - line2[1].y,\r\n                line2[0].x - line2[1].x);\r\n            var diff = angle1 - angle2;\r\n            if (diff > Math.PI || diff < -Math.PI) {\r\n                diff = angle2 - angle1;\r\n            }\r\n            return diff;\r\n        }\r\n\r\n        // does the path a-b-c describe a left turn?\r\n        private static isLeft(a, b, c) {\r\n            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;\r\n        }\r\n\r\n        // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to\r\n        // see if it exists in the list\r\n        private static getOrder(pairs: { l: number; r: number }[]): (l: number, r: number) => boolean {\r\n            var outgoing = {};\r\n            for (var i = 0; i < pairs.length; i++) {\r\n                var p = pairs[i];\r\n                if (typeof outgoing[p.l] === 'undefined') outgoing[p.l] = {};\r\n                outgoing[p.l][p.r] = true;\r\n            }\r\n            return (l, r) => typeof outgoing[l] !== 'undefined' && outgoing[l][r];\r\n        }\r\n\r\n        // returns an ordering (a lookup function) that determines the correct order to nudge the\r\n        // edge paths apart to minimize crossings\r\n        static orderEdges(edges) {\r\n            var edgeOrder = [];\r\n            for (var i = 0; i < edges.length - 1; i++) {\r\n                for (var j = i + 1; j < edges.length; j++) {\r\n                    var e = edges[i],\r\n                        f = edges[j],\r\n                        lcs = new LongestCommonSubsequence(e, f);\r\n                    var u, vi, vj;\r\n                    if (lcs.length === 0)\r\n                        continue; // no common subpath\r\n                    if (lcs.reversed) {\r\n                        // if we found a common subpath but one of the edges runs the wrong way,\r\n                        // then reverse f.\r\n                        f.reverse();\r\n                        f.reversed = true;\r\n                        lcs = new LongestCommonSubsequence(e, f);\r\n                    }\r\n                    if ((lcs.si <= 0 || lcs.ti <= 0) &&\r\n                        (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\r\n                        // the paths do not diverge, so make an arbitrary ordering decision\r\n                        edgeOrder.push({ l: i, r: j });\r\n                        continue;\r\n                    }\r\n                    if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\r\n                        // if the common subsequence of the\r\n                        // two edges being considered goes all the way to the\r\n                        // end of one (or both) of the lines then we have to\r\n                        // base our ordering decision on the other end of the\r\n                        // common subsequence\r\n                        u = e[lcs.si + 1];\r\n                        vj = e[lcs.si - 1];\r\n                        vi = f[lcs.ti - 1];\r\n                    } else {\r\n                        u = e[lcs.si + lcs.length - 2];\r\n                        vi = e[lcs.si + lcs.length];\r\n                        vj = f[lcs.ti + lcs.length];\r\n                    }\r\n                    if (GridRouter.isLeft(u, vi, vj)) {\r\n                        edgeOrder.push({ l: j, r: i });\r\n                    } else {\r\n                        edgeOrder.push({ l: i, r: j });\r\n                    }\r\n                }\r\n            }\r\n            //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });\r\n            return GridRouter.getOrder(edgeOrder);\r\n        }\r\n\r\n        // for an orthogonal path described by a sequence of points, create a list of segments\r\n        // if consecutive segments would make a straight line they are merged into a single segment\r\n        // segments are over cloned points, not the original vertices\r\n        static makeSegments(path: Point[]): Point[][] {\r\n            function copyPoint(p: Point) {\r\n                return <Point>{ x: p.x, y: p.y };\r\n            }\r\n            var isStraight = (a, b, c) => Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001;\r\n            var segments = [];\r\n            var a = copyPoint(path[0]);\r\n            for (var i = 1; i < path.length; i++) {\r\n                var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;\r\n                if (!c || !isStraight(a, b, c)) {\r\n                    segments.push([a, b]);\r\n                    a = b;\r\n                }\r\n            }\r\n            return segments;\r\n        }\r\n\r\n        // find a route between node s and node t\r\n        // returns an array of indices to verts\r\n        route(s: number, t: number): Point[] {\r\n            var source = this.nodes[<number>s], target = this.nodes[<number>t];\r\n            this.obstacles = this.siblingObstacles(source, target);\r\n\r\n            var obstacleLookup = {};\r\n            this.obstacles.forEach(o => obstacleLookup[o.id] = o);\r\n            this.passableEdges = this.edges.filter(e=> {\r\n                var u = this.verts[e.source],\r\n                    v = this.verts[e.target];\r\n                return !(u.node && u.node.id in obstacleLookup\r\n                    || v.node && v.node.id in obstacleLookup);\r\n            });\r\n\r\n            // add dummy segments linking ports inside source and target\r\n            for (var i = 1; i < source.ports.length; i++) {\r\n                var u = source.ports[0].id;\r\n                var v = source.ports[i].id;\r\n                this.passableEdges.push({\r\n                    source: u,\r\n                    target: v,\r\n                    length: 0\r\n                });\r\n            }\r\n            for (var i = 1; i < target.ports.length; i++) {\r\n                var u = target.ports[0].id;\r\n                var v = target.ports[i].id;\r\n                this.passableEdges.push({\r\n                    source: u,\r\n                    target: v,\r\n                    length: 0\r\n                });\r\n            }\r\n\r\n            var getSource = e=> e.source,\r\n                getTarget = e=> e.target,\r\n                getLength = e=> e.length;\r\n\r\n            var shortestPathCalculator = new Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\r\n            var bendPenalty = (u, v, w) => {\r\n                var a = this.verts[u], b = this.verts[v], c = this.verts[w];\r\n                var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);\r\n                // don't count bends from internal node edges\r\n                if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)\r\n                    return 0;\r\n                return dx > 1 && dy > 1 ? 1000 : 0;\r\n            };\r\n\r\n            // get shortest path\r\n            var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(\r\n                source.ports[0].id, target.ports[0].id,\r\n                bendPenalty);\r\n\r\n            // shortest path is reversed and does not include the target port\r\n            var pathPoints = shortestPath.reverse().map(vi => this.verts[vi]);\r\n            pathPoints.push(this.nodes[target.id].ports[0]);\r\n\r\n            // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)\r\n            return pathPoints.filter((v, i) =>\r\n                !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source\r\n                    || i > 0 && v.node === target && pathPoints[i - 1].node === target));\r\n        }\r\n\r\n        static getRoutePath(route: Point[][], cornerradius: number, arrowwidth: number, arrowheight: number): { routepath: string; arrowpath: string } {\r\n            var result = {\r\n                routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\r\n                arrowpath: ''\r\n            };\r\n            if (route.length > 1) {\r\n                for (var i = 0; i < route.length; i++) {\r\n                    var li = route[i];\r\n                    var x = li[1].x, y = li[1].y;\r\n                    var dx = x - li[0].x;\r\n                    var dy = y - li[0].y;\r\n                    if (i < route.length - 1) {\r\n                        if (Math.abs(dx) > 0) {\r\n                            x -= dx / Math.abs(dx) * cornerradius;\r\n                        } else {\r\n                            y -= dy / Math.abs(dy) * cornerradius;\r\n                        }\r\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                        var l = route[i + 1];\r\n                        var x0 = l[0].x, y0 = l[0].y;\r\n                        var x1 = l[1].x;\r\n                        var y1 = l[1].y;\r\n                        dx = x1 - x0;\r\n                        dy = y1 - y0;\r\n                        var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\r\n                        //console.log(cola.GridRouter.angleBetween2Lines(li, l))\r\n                        var x2, y2;\r\n                        if (Math.abs(dx) > 0) {\r\n                            x2 = x0 + dx / Math.abs(dx) * cornerradius;\r\n                            y2 = y0;\r\n                        } else {\r\n                            x2 = x0;\r\n                            y2 = y0 + dy / Math.abs(dy) * cornerradius;\r\n                        }\r\n                        var cx = Math.abs(x2 - x);\r\n                        var cy = Math.abs(y2 - y);\r\n                        result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\r\n                    } else {\r\n                        var arrowtip = [x, y];\r\n                        var arrowcorner1, arrowcorner2;\r\n                        if (Math.abs(dx) > 0) {\r\n                            x -= dx / Math.abs(dx) * arrowheight;\r\n                            arrowcorner1 = [x, y + arrowwidth];\r\n                            arrowcorner2 = [x, y - arrowwidth];\r\n                        } else {\r\n                            y -= dy / Math.abs(dy) * arrowheight;\r\n                            arrowcorner1 = [x + arrowwidth, y];\r\n                            arrowcorner2 = [x - arrowwidth, y];\r\n                        }\r\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                        if (arrowheight > 0) {\r\n                            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                            + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                var li = route[0];\r\n                var x = li[1].x, y = li[1].y;\r\n                var dx = x - li[0].x;\r\n                var dy = y - li[0].y;\r\n                var arrowtip = [x, y];\r\n                var arrowcorner1, arrowcorner2;\r\n                if (Math.abs(dx) > 0) {\r\n                    x -= dx / Math.abs(dx) * arrowheight;\r\n                    arrowcorner1 = [x, y + arrowwidth];\r\n                    arrowcorner2 = [x, y - arrowwidth];\r\n                } else {\r\n                    y -= dy / Math.abs(dy) * arrowheight;\r\n                    arrowcorner1 = [x + arrowwidth, y];\r\n                    arrowcorner2 = [x - arrowwidth, y];\r\n                }\r\n                result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                if (arrowheight > 0) {\r\n                    result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                    + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n"]}},"hash":"0b97fe181cdca3dbcfb56dbe562ba3c7","cacheData":{"env":{}}}