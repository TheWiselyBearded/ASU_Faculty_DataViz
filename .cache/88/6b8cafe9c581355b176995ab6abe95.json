{"id":"node_modules/webcola/dist/src/vpsc.js","dependencies":[{"name":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/dist/src/vpsc.js.map","includedInParent":true,"mtime":1517462217000},{"name":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/WebCola/src/vpsc.ts","includedInParent":true,"mtime":1516884256000},{"name":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/package.json","includedInParent":true,"mtime":1550967406043},{"name":"/Users/reza/Documents/Meteor/ASU Data Viz Tinnapple/Graph/node_modules/webcola/package.json","includedInParent":true,"mtime":1550967405642}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar PositionStats = (function () {\r\n    function PositionStats(scale) {\r\n        this.scale = scale;\r\n        this.AB = 0;\r\n        this.AD = 0;\r\n        this.A2 = 0;\r\n    }\r\n    PositionStats.prototype.addVariable = function (v) {\r\n        var ai = this.scale / v.scale;\r\n        var bi = v.offset / v.scale;\r\n        var wi = v.weight;\r\n        this.AB += wi * ai * bi;\r\n        this.AD += wi * ai * v.desiredPosition;\r\n        this.A2 += wi * ai * ai;\r\n    };\r\n    PositionStats.prototype.getPosn = function () {\r\n        return (this.AD - this.AB) / this.A2;\r\n    };\r\n    return PositionStats;\r\n}());\r\nexports.PositionStats = PositionStats;\r\nvar Constraint = (function () {\r\n    function Constraint(left, right, gap, equality) {\r\n        if (equality === void 0) { equality = false; }\r\n        this.left = left;\r\n        this.right = right;\r\n        this.gap = gap;\r\n        this.equality = equality;\r\n        this.active = false;\r\n        this.unsatisfiable = false;\r\n        this.left = left;\r\n        this.right = right;\r\n        this.gap = gap;\r\n        this.equality = equality;\r\n    }\r\n    Constraint.prototype.slack = function () {\r\n        return this.unsatisfiable ? Number.MAX_VALUE\r\n            : this.right.scale * this.right.position() - this.gap\r\n                - this.left.scale * this.left.position();\r\n    };\r\n    return Constraint;\r\n}());\r\nexports.Constraint = Constraint;\r\nvar Variable = (function () {\r\n    function Variable(desiredPosition, weight, scale) {\r\n        if (weight === void 0) { weight = 1; }\r\n        if (scale === void 0) { scale = 1; }\r\n        this.desiredPosition = desiredPosition;\r\n        this.weight = weight;\r\n        this.scale = scale;\r\n        this.offset = 0;\r\n    }\r\n    Variable.prototype.dfdv = function () {\r\n        return 2.0 * this.weight * (this.position() - this.desiredPosition);\r\n    };\r\n    Variable.prototype.position = function () {\r\n        return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\r\n    };\r\n    Variable.prototype.visitNeighbours = function (prev, f) {\r\n        var ff = function (c, next) { return c.active && prev !== next && f(c, next); };\r\n        this.cOut.forEach(function (c) { return ff(c, c.right); });\r\n        this.cIn.forEach(function (c) { return ff(c, c.left); });\r\n    };\r\n    return Variable;\r\n}());\r\nexports.Variable = Variable;\r\nvar Block = (function () {\r\n    function Block(v) {\r\n        this.vars = [];\r\n        v.offset = 0;\r\n        this.ps = new PositionStats(v.scale);\r\n        this.addVariable(v);\r\n    }\r\n    Block.prototype.addVariable = function (v) {\r\n        v.block = this;\r\n        this.vars.push(v);\r\n        this.ps.addVariable(v);\r\n        this.posn = this.ps.getPosn();\r\n    };\r\n    Block.prototype.updateWeightedPosition = function () {\r\n        this.ps.AB = this.ps.AD = this.ps.A2 = 0;\r\n        for (var i = 0, n = this.vars.length; i < n; ++i)\r\n            this.ps.addVariable(this.vars[i]);\r\n        this.posn = this.ps.getPosn();\r\n    };\r\n    Block.prototype.compute_lm = function (v, u, postAction) {\r\n        var _this = this;\r\n        var dfdv = v.dfdv();\r\n        v.visitNeighbours(u, function (c, next) {\r\n            var _dfdv = _this.compute_lm(next, v, postAction);\r\n            if (next === c.right) {\r\n                dfdv += _dfdv * c.left.scale;\r\n                c.lm = _dfdv;\r\n            }\r\n            else {\r\n                dfdv += _dfdv * c.right.scale;\r\n                c.lm = -_dfdv;\r\n            }\r\n            postAction(c);\r\n        });\r\n        return dfdv / v.scale;\r\n    };\r\n    Block.prototype.populateSplitBlock = function (v, prev) {\r\n        var _this = this;\r\n        v.visitNeighbours(prev, function (c, next) {\r\n            next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\r\n            _this.addVariable(next);\r\n            _this.populateSplitBlock(next, v);\r\n        });\r\n    };\r\n    Block.prototype.traverse = function (visit, acc, v, prev) {\r\n        var _this = this;\r\n        if (v === void 0) { v = this.vars[0]; }\r\n        if (prev === void 0) { prev = null; }\r\n        v.visitNeighbours(prev, function (c, next) {\r\n            acc.push(visit(c));\r\n            _this.traverse(visit, acc, next, v);\r\n        });\r\n    };\r\n    Block.prototype.findMinLM = function () {\r\n        var m = null;\r\n        this.compute_lm(this.vars[0], null, function (c) {\r\n            if (!c.equality && (m === null || c.lm < m.lm))\r\n                m = c;\r\n        });\r\n        return m;\r\n    };\r\n    Block.prototype.findMinLMBetween = function (lv, rv) {\r\n        this.compute_lm(lv, null, function () { });\r\n        var m = null;\r\n        this.findPath(lv, null, rv, function (c, next) {\r\n            if (!c.equality && c.right === next && (m === null || c.lm < m.lm))\r\n                m = c;\r\n        });\r\n        return m;\r\n    };\r\n    Block.prototype.findPath = function (v, prev, to, visit) {\r\n        var _this = this;\r\n        var endFound = false;\r\n        v.visitNeighbours(prev, function (c, next) {\r\n            if (!endFound && (next === to || _this.findPath(next, v, to, visit))) {\r\n                endFound = true;\r\n                visit(c, next);\r\n            }\r\n        });\r\n        return endFound;\r\n    };\r\n    Block.prototype.isActiveDirectedPathBetween = function (u, v) {\r\n        if (u === v)\r\n            return true;\r\n        var i = u.cOut.length;\r\n        while (i--) {\r\n            var c = u.cOut[i];\r\n            if (c.active && this.isActiveDirectedPathBetween(c.right, v))\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    Block.split = function (c) {\r\n        c.active = false;\r\n        return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\r\n    };\r\n    Block.createSplitBlock = function (startVar) {\r\n        var b = new Block(startVar);\r\n        b.populateSplitBlock(startVar, null);\r\n        return b;\r\n    };\r\n    Block.prototype.splitBetween = function (vl, vr) {\r\n        var c = this.findMinLMBetween(vl, vr);\r\n        if (c !== null) {\r\n            var bs = Block.split(c);\r\n            return { constraint: c, lb: bs[0], rb: bs[1] };\r\n        }\r\n        return null;\r\n    };\r\n    Block.prototype.mergeAcross = function (b, c, dist) {\r\n        c.active = true;\r\n        for (var i = 0, n = b.vars.length; i < n; ++i) {\r\n            var v = b.vars[i];\r\n            v.offset += dist;\r\n            this.addVariable(v);\r\n        }\r\n        this.posn = this.ps.getPosn();\r\n    };\r\n    Block.prototype.cost = function () {\r\n        var sum = 0, i = this.vars.length;\r\n        while (i--) {\r\n            var v = this.vars[i], d = v.position() - v.desiredPosition;\r\n            sum += d * d * v.weight;\r\n        }\r\n        return sum;\r\n    };\r\n    return Block;\r\n}());\r\nexports.Block = Block;\r\nvar Blocks = (function () {\r\n    function Blocks(vs) {\r\n        this.vs = vs;\r\n        var n = vs.length;\r\n        this.list = new Array(n);\r\n        while (n--) {\r\n            var b = new Block(vs[n]);\r\n            this.list[n] = b;\r\n            b.blockInd = n;\r\n        }\r\n    }\r\n    Blocks.prototype.cost = function () {\r\n        var sum = 0, i = this.list.length;\r\n        while (i--)\r\n            sum += this.list[i].cost();\r\n        return sum;\r\n    };\r\n    Blocks.prototype.insert = function (b) {\r\n        b.blockInd = this.list.length;\r\n        this.list.push(b);\r\n    };\r\n    Blocks.prototype.remove = function (b) {\r\n        var last = this.list.length - 1;\r\n        var swapBlock = this.list[last];\r\n        this.list.length = last;\r\n        if (b !== swapBlock) {\r\n            this.list[b.blockInd] = swapBlock;\r\n            swapBlock.blockInd = b.blockInd;\r\n        }\r\n    };\r\n    Blocks.prototype.merge = function (c) {\r\n        var l = c.left.block, r = c.right.block;\r\n        var dist = c.right.offset - c.left.offset - c.gap;\r\n        if (l.vars.length < r.vars.length) {\r\n            r.mergeAcross(l, c, dist);\r\n            this.remove(l);\r\n        }\r\n        else {\r\n            l.mergeAcross(r, c, -dist);\r\n            this.remove(r);\r\n        }\r\n    };\r\n    Blocks.prototype.forEach = function (f) {\r\n        this.list.forEach(f);\r\n    };\r\n    Blocks.prototype.updateBlockPositions = function () {\r\n        this.list.forEach(function (b) { return b.updateWeightedPosition(); });\r\n    };\r\n    Blocks.prototype.split = function (inactive) {\r\n        var _this = this;\r\n        this.updateBlockPositions();\r\n        this.list.forEach(function (b) {\r\n            var v = b.findMinLM();\r\n            if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\r\n                b = v.left.block;\r\n                Block.split(v).forEach(function (nb) { return _this.insert(nb); });\r\n                _this.remove(b);\r\n                inactive.push(v);\r\n            }\r\n        });\r\n    };\r\n    return Blocks;\r\n}());\r\nexports.Blocks = Blocks;\r\nvar Solver = (function () {\r\n    function Solver(vs, cs) {\r\n        this.vs = vs;\r\n        this.cs = cs;\r\n        this.vs = vs;\r\n        vs.forEach(function (v) {\r\n            v.cIn = [], v.cOut = [];\r\n        });\r\n        this.cs = cs;\r\n        cs.forEach(function (c) {\r\n            c.left.cOut.push(c);\r\n            c.right.cIn.push(c);\r\n        });\r\n        this.inactive = cs.map(function (c) { c.active = false; return c; });\r\n        this.bs = null;\r\n    }\r\n    Solver.prototype.cost = function () {\r\n        return this.bs.cost();\r\n    };\r\n    Solver.prototype.setStartingPositions = function (ps) {\r\n        this.inactive = this.cs.map(function (c) { c.active = false; return c; });\r\n        this.bs = new Blocks(this.vs);\r\n        this.bs.forEach(function (b, i) { return b.posn = ps[i]; });\r\n    };\r\n    Solver.prototype.setDesiredPositions = function (ps) {\r\n        this.vs.forEach(function (v, i) { return v.desiredPosition = ps[i]; });\r\n    };\r\n    Solver.prototype.mostViolated = function () {\r\n        var minSlack = Number.MAX_VALUE, v = null, l = this.inactive, n = l.length, deletePoint = n;\r\n        for (var i = 0; i < n; ++i) {\r\n            var c = l[i];\r\n            if (c.unsatisfiable)\r\n                continue;\r\n            var slack = c.slack();\r\n            if (c.equality || slack < minSlack) {\r\n                minSlack = slack;\r\n                v = c;\r\n                deletePoint = i;\r\n                if (c.equality)\r\n                    break;\r\n            }\r\n        }\r\n        if (deletePoint !== n &&\r\n            (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality)) {\r\n            l[deletePoint] = l[n - 1];\r\n            l.length = n - 1;\r\n        }\r\n        return v;\r\n    };\r\n    Solver.prototype.satisfy = function () {\r\n        if (this.bs == null) {\r\n            this.bs = new Blocks(this.vs);\r\n        }\r\n        this.bs.split(this.inactive);\r\n        var v = null;\r\n        while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\r\n            var lb = v.left.block, rb = v.right.block;\r\n            if (lb !== rb) {\r\n                this.bs.merge(v);\r\n            }\r\n            else {\r\n                if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\r\n                    v.unsatisfiable = true;\r\n                    continue;\r\n                }\r\n                var split = lb.splitBetween(v.left, v.right);\r\n                if (split !== null) {\r\n                    this.bs.insert(split.lb);\r\n                    this.bs.insert(split.rb);\r\n                    this.bs.remove(lb);\r\n                    this.inactive.push(split.constraint);\r\n                }\r\n                else {\r\n                    v.unsatisfiable = true;\r\n                    continue;\r\n                }\r\n                if (v.slack() >= 0) {\r\n                    this.inactive.push(v);\r\n                }\r\n                else {\r\n                    this.bs.merge(v);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Solver.prototype.solve = function () {\r\n        this.satisfy();\r\n        var lastcost = Number.MAX_VALUE, cost = this.bs.cost();\r\n        while (Math.abs(lastcost - cost) > 0.0001) {\r\n            this.satisfy();\r\n            lastcost = cost;\r\n            cost = this.bs.cost();\r\n        }\r\n        return cost;\r\n    };\r\n    Solver.LAGRANGIAN_TOLERANCE = -1e-4;\r\n    Solver.ZERO_UPPERBOUND = -1e-10;\r\n    return Solver;\r\n}());\r\nexports.Solver = Solver;\r\nfunction removeOverlapInOneDimension(spans, lowerBound, upperBound) {\r\n    var vs = spans.map(function (s) { return new Variable(s.desiredCenter); });\r\n    var cs = [];\r\n    var n = spans.length;\r\n    for (var i = 0; i < n - 1; i++) {\r\n        var left = spans[i], right = spans[i + 1];\r\n        cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));\r\n    }\r\n    var leftMost = vs[0], rightMost = vs[n - 1], leftMostSize = spans[0].size / 2, rightMostSize = spans[n - 1].size / 2;\r\n    var vLower = null, vUpper = null;\r\n    if (lowerBound) {\r\n        vLower = new Variable(lowerBound, leftMost.weight * 1000);\r\n        vs.push(vLower);\r\n        cs.push(new Constraint(vLower, leftMost, leftMostSize));\r\n    }\r\n    if (upperBound) {\r\n        vUpper = new Variable(upperBound, rightMost.weight * 1000);\r\n        vs.push(vUpper);\r\n        cs.push(new Constraint(rightMost, vUpper, rightMostSize));\r\n    }\r\n    var solver = new Solver(vs, cs);\r\n    solver.solve();\r\n    return {\r\n        newCenters: vs.slice(0, spans.length).map(function (v) { return v.position(); }),\r\n        lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,\r\n        upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize\r\n    };\r\n}\r\nexports.removeOverlapInOneDimension = removeOverlapInOneDimension;\r\n","map":{"version":3,"file":"vpsc.js","sourceRoot":"","sources":["../../WebCola/src/vpsc.ts"],"names":[],"mappings":";;AAAI;IAKI,uBAAmB,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;QAJhC,OAAE,GAAW,CAAC,CAAC;QACf,OAAE,GAAW,CAAC,CAAC;QACf,OAAE,GAAW,CAAC,CAAC;IAEoB,CAAC;IAEpC,mCAAW,GAAX,UAAY,CAAW;QACnB,IAAI,EAAE,GAAG,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC;QAC9B,IAAI,EAAE,GAAG,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC;QAC5B,IAAI,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC;QAClB,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;QACxB,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,eAAe,CAAC;QACvC,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;IAC5B,CAAC;IAED,+BAAO,GAAP;QACI,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;IACzC,CAAC;IACL,oBAAC;AAAD,CAAC,AAnBD,IAmBC;AAnBY,sCAAa;AAqB1B;IAKI,oBAAmB,IAAc,EAAS,KAAe,EAAS,GAAW,EAAS,QAAyB;QAAzB,yBAAA,EAAA,gBAAyB;QAA5F,SAAI,GAAJ,IAAI,CAAU;QAAS,UAAK,GAAL,KAAK,CAAU;QAAS,QAAG,GAAH,GAAG,CAAQ;QAAS,aAAQ,GAAR,QAAQ,CAAiB;QAH/G,WAAM,GAAY,KAAK,CAAC;QACxB,kBAAa,GAAY,KAAK,CAAC;QAG3B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC7B,CAAC;IAED,0BAAK,GAAL;QACI,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS;YACxC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,IAAI,CAAC,GAAG;kBACnD,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;IACjD,CAAC;IACL,iBAAC;AAAD,CAAC,AAjBD,IAiBC;AAjBY,gCAAU;AAmBvB;IAMI,kBAAmB,eAAuB,EAAS,MAAkB,EAAS,KAAiB;QAA5C,uBAAA,EAAA,UAAkB;QAAS,sBAAA,EAAA,SAAiB;QAA5E,oBAAe,GAAf,eAAe,CAAQ;QAAS,WAAM,GAAN,MAAM,CAAY;QAAS,UAAK,GAAL,KAAK,CAAY;QAL/F,WAAM,GAAW,CAAC,CAAC;IAK+E,CAAC;IAEnG,uBAAI,GAAJ;QACI,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC;IACxE,CAAC;IAED,2BAAQ,GAAR;QACI,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;IAC9E,CAAC;IAGD,kCAAe,GAAf,UAAgB,IAAc,EAAE,CAA0C;QACtE,IAAI,EAAE,GAAG,UAAC,CAAC,EAAE,IAAI,IAAK,OAAA,CAAC,CAAC,MAAM,IAAI,IAAI,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,EAAvC,CAAuC,CAAC;QAC9D,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,UAAA,CAAC,IAAG,OAAA,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,EAAd,CAAc,CAAC,CAAC;QACtC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,UAAA,CAAC,IAAG,OAAA,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,EAAb,CAAa,CAAC,CAAC;IACxC,CAAC;IACL,eAAC;AAAD,CAAC,AAtBD,IAsBC;AAtBY,4BAAQ;AAwBrB;IAMI,eAAY,CAAW;QALvB,SAAI,GAAe,EAAE,CAAC;QAMlB,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;QACb,IAAI,CAAC,EAAE,GAAG,IAAI,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QACrC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;IACxB,CAAC;IAEO,2BAAW,GAAnB,UAAoB,CAAW;QAC3B,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC;QACf,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAClB,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QACvB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC;IAClC,CAAC;IAGD,sCAAsB,GAAtB;QACI,IAAI,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;QACzC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC;YAC5C,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;QACtC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC;IAClC,CAAC;IAEO,0BAAU,GAAlB,UAAmB,CAAW,EAAE,CAAW,EAAE,UAAiC;QAA9E,iBAcC;QAbG,IAAI,IAAI,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;QACpB,CAAC,CAAC,eAAe,CAAC,CAAC,EAAE,UAAC,CAAC,EAAE,IAAI;YACzB,IAAI,KAAK,GAAG,KAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;YACjD,EAAE,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACnB,IAAI,IAAI,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC7B,CAAC,CAAC,EAAE,GAAG,KAAK,CAAC;YACjB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,IAAI,IAAI,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC;gBAC9B,CAAC,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC;YAClB,CAAC;YACD,UAAU,CAAC,CAAC,CAAC,CAAC;QAClB,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,IAAI,GAAG,CAAC,CAAC,KAAK,CAAC;IAC1B,CAAC;IAEO,kCAAkB,GAA1B,UAA2B,CAAW,EAAE,IAAc;QAAtD,iBAMC;QALG,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,UAAC,CAAC,EAAE,IAAI;YAC5B,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YAC7D,KAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;YACvB,KAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QACrC,CAAC,CAAC,CAAC;IACP,CAAC;IAGD,wBAAQ,GAAR,UAAS,KAA6B,EAAE,GAAU,EAAE,CAA0B,EAAE,IAAmB;QAAnG,iBAKC;QALmD,kBAAA,EAAA,IAAc,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAAE,qBAAA,EAAA,WAAmB;QAC/F,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,UAAC,CAAC,EAAE,IAAI;YAC5B,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACnB,KAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;QACvC,CAAC,CAAC,CAAC;IACP,CAAC;IAKD,yBAAS,GAAT;QACI,IAAI,CAAC,GAAe,IAAI,CAAC;QACzB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,UAAA,CAAC;YACjC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;gBAAC,CAAC,GAAG,CAAC,CAAC;QAC1D,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,CAAC,CAAC;IACb,CAAC;IAEO,gCAAgB,GAAxB,UAAyB,EAAY,EAAE,EAAY;QAC/C,IAAI,CAAC,UAAU,CAAC,EAAE,EAAE,IAAI,EAAE,cAAO,CAAC,CAAC,CAAC;QACpC,IAAI,CAAC,GAAG,IAAI,CAAC;QACb,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,UAAC,CAAC,EAAE,IAAI;YAChC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,KAAK,KAAK,IAAI,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;gBAAC,CAAC,GAAG,CAAC,CAAC;QAC9E,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,CAAC,CAAC;IACb,CAAC;IAEO,wBAAQ,GAAhB,UAAiB,CAAW,EAAE,IAAc,EAAE,EAAY,EAAE,KAA2C;QAAvG,iBAUC;QATG,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,UAAC,CAAC,EAAE,IAAI;YAC5B,EAAE,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,IAAI,KAAK,EAAE,IAAI,KAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,CACpE,CAAC;gBACG,QAAQ,GAAG,IAAI,CAAC;gBAChB,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YACnB,CAAC;QACL,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,QAAQ,CAAC;IACpB,CAAC;IAID,2CAA2B,GAA3B,UAA4B,CAAW,EAAE,CAAW;QAChD,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QACzB,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC;QACtB,OAAM,CAAC,EAAE,EAAE,CAAC;YACR,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAClB,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,2BAA2B,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;gBACzD,MAAM,CAAC,IAAI,CAAC;QACpB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAGM,WAAK,GAAZ,UAAa,CAAa;QAKtB,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC;QACjB,MAAM,CAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;IAC7E,CAAC;IAEc,sBAAgB,GAA/B,UAAgC,QAAkB;QAC9C,IAAI,CAAC,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,CAAC;QAC5B,CAAC,CAAC,kBAAkB,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QACrC,MAAM,CAAC,CAAC,CAAC;IACb,CAAC;IAGD,4BAAY,GAAZ,UAAa,EAAY,EAAE,EAAY;QAKnC,IAAI,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QACtC,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;YACb,IAAI,EAAE,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACxB,MAAM,CAAC,EAAE,UAAU,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;QACnD,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED,2BAAW,GAAX,UAAY,CAAQ,EAAE,CAAa,EAAE,IAAY;QAC7C,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;QAChB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC;YAC5C,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAClB,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC;YACjB,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QACxB,CAAC;QACD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC;IAClC,CAAC;IAED,oBAAI,GAAJ;QACI,IAAI,GAAG,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;QAClC,OAAO,CAAC,EAAE,EAAE,CAAC;YACT,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAChB,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC,eAAe,CAAC;YACzC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;QAC5B,CAAC;QACD,MAAM,CAAC,GAAG,CAAC;IACf,CAAC;IASL,YAAC;AAAD,CAAC,AAlKD,IAkKC;AAlKY,sBAAK;AAoKlB;IAGI,gBAAmB,EAAc;QAAd,OAAE,GAAF,EAAE,CAAY;QAC7B,IAAI,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC;QAClB,IAAI,CAAC,IAAI,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;QACzB,OAAO,CAAC,EAAE,EAAE,CAAC;YACT,IAAI,CAAC,GAAG,IAAI,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YACzB,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YACjB,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC;QACnB,CAAC;IACL,CAAC;IAED,qBAAI,GAAJ;QACI,IAAI,GAAG,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;QAClC,OAAO,CAAC,EAAE;YAAE,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;QACvC,MAAM,CAAC,GAAG,CAAC;IACf,CAAC;IAED,uBAAM,GAAN,UAAO,CAAQ;QAIX,CAAC,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;QAC9B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAKtB,CAAC;IAED,uBAAM,GAAN,UAAO,CAAQ;QAKX,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAChC,IAAI,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACxB,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC;YAClB,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC;YAClC,SAAS,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAIpC,CAAC;IACL,CAAC;IAID,sBAAK,GAAL,UAAM,CAAa;QACf,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC;QAIxC,IAAI,IAAI,GAAG,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC;QAClD,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YAChC,CAAC,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;YAC1B,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACnB,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,CAAC,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;YAC3B,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACnB,CAAC;IAKL,CAAC;IAED,wBAAO,GAAP,UAAQ,CAAgC;QACpC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC;IAGD,qCAAoB,GAApB;QACI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,UAAA,CAAC,IAAG,OAAA,CAAC,CAAC,sBAAsB,EAAE,EAA1B,CAA0B,CAAC,CAAC;IACtD,CAAC;IAGD,sBAAK,GAAL,UAAM,QAAsB;QAA5B,iBAeC;QAdG,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,UAAA,CAAC;YACf,IAAI,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,CAAC;YACtB,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,EAAE,GAAG,MAAM,CAAC,oBAAoB,CAAC,CAAC,CAAC;gBACnD,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;gBACjB,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,UAAA,EAAE,IAAE,OAAA,KAAI,CAAC,MAAM,CAAC,EAAE,CAAC,EAAf,CAAe,CAAC,CAAC;gBAC5C,KAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;gBACf,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAKrB,CAAC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAoBL,aAAC;AAAD,CAAC,AAlHD,IAkHC;AAlHY,wBAAM;AAoHnB;IAOI,gBAAmB,EAAc,EAAS,EAAgB;QAAvC,OAAE,GAAF,EAAE,CAAY;QAAS,OAAE,GAAF,EAAE,CAAc;QACtD,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;QACb,EAAE,CAAC,OAAO,CAAC,UAAA,CAAC;YACR,CAAC,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC;QAI5B,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;QACb,EAAE,CAAC,OAAO,CAAC,UAAA,CAAC;YACR,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACpB,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAIxB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC,GAAG,CAAC,UAAA,CAAC,IAAK,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5D,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC;IACnB,CAAC;IAED,qBAAI,GAAJ;QACI,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;IAC1B,CAAC;IAID,qCAAoB,GAApB,UAAqB,EAAY;QAC7B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,UAAA,CAAC,IAAK,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACjE,IAAI,CAAC,EAAE,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC9B,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,EAAd,CAAc,CAAC,CAAC;IAC9C,CAAC;IAED,oCAAmB,GAAnB,UAAoB,EAAY;QAC5B,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,eAAe,GAAG,EAAE,CAAC,CAAC,CAAC,EAAzB,CAAyB,CAAC,CAAC;IACzD,CAAC;IA2BO,6BAAY,GAApB;QACI,IAAI,QAAQ,GAAG,MAAM,CAAC,SAAS,EAC3B,CAAC,GAAe,IAAI,EACpB,CAAC,GAAG,IAAI,CAAC,QAAQ,EACjB,CAAC,GAAG,CAAC,CAAC,MAAM,EACZ,WAAW,GAAG,CAAC,CAAC;QACpB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC;YACzB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACb,EAAE,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC;gBAAC,QAAQ,CAAC;YAC9B,IAAI,KAAK,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC;YACtB,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,IAAI,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC;gBACjC,QAAQ,GAAG,KAAK,CAAC;gBACjB,CAAC,GAAG,CAAC,CAAC;gBACN,WAAW,GAAG,CAAC,CAAC;gBAChB,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;oBAAC,KAAK,CAAC;YAC1B,CAAC;QACL,CAAC;QACD,EAAE,CAAC,CAAC,WAAW,KAAK,CAAC;YACjB,CAAC,QAAQ,GAAG,MAAM,CAAC,eAAe,IAAI,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,CACnE,CAAC;YACG,CAAC,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAC1B,CAAC,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;QACrB,CAAC;QACD,MAAM,CAAC,CAAC,CAAC;IACb,CAAC;IAID,wBAAO,GAAP;QACI,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC;YAClB,IAAI,CAAC,EAAE,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAClC,CAAC;QAID,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC7B,IAAI,CAAC,GAAe,IAAI,CAAC;QACzB,OAAO,CAAC,CAAC,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,KAAK,EAAE,GAAG,MAAM,CAAC,eAAe,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC;YAClG,IAAI,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC;YAM1C,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;gBACZ,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACrB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,EAAE,CAAC,CAAC,EAAE,CAAC,2BAA2B,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAElD,CAAC,CAAC,aAAa,GAAG,IAAI,CAAC;oBACvB,QAAQ,CAAC;gBACb,CAAC;gBAED,IAAI,KAAK,GAAG,EAAE,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;gBAC7C,EAAE,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC;oBACjB,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;oBACzB,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;oBACzB,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;oBACnB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;gBACzC,CAAC;gBAAC,IAAI,CAAC,CAAC;oBAIJ,CAAC,CAAC,aAAa,GAAG,IAAI,CAAC;oBACvB,QAAQ,CAAC;gBACb,CAAC;gBACD,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;oBAKjB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC1B,CAAC;gBAAC,IAAI,CAAC,CAAC;oBAIJ,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACrB,CAAC;YACL,CAAC;QAML,CAAC;IAIL,CAAC;IAGD,sBAAK,GAAL;QACI,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,IAAI,QAAQ,GAAG,MAAM,CAAC,SAAS,EAAE,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;QACvD,OAAO,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,MAAM,EAAE,CAAC;YACxC,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,QAAQ,GAAG,IAAI,CAAC;YAChB,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;QAC1B,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IApKM,2BAAoB,GAAG,CAAC,IAAI,CAAC;IAC7B,sBAAe,GAAG,CAAC,KAAK,CAAC;IAoKpC,aAAC;CAAA,AAzKD,IAyKC;AAzKY,wBAAM;AAiLnB,qCAA4C,KAAgD,EAAE,UAAmB,EAAE,UAAmB;IAGlI,IAAM,EAAE,GAAe,KAAK,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,IAAI,QAAQ,CAAC,CAAC,CAAC,aAAa,CAAC,EAA7B,CAA6B,CAAC,CAAC;IACrE,IAAM,EAAE,GAAiB,EAAE,CAAC;IAC5B,IAAM,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC;IACvB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC7B,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAC5C,EAAE,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAC5E,CAAC;IACD,IAAM,QAAQ,GAAG,EAAE,CAAC,CAAC,CAAC,EAClB,SAAS,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,EACrB,YAAY,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,EAChC,aAAa,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;IAC1C,IAAI,MAAM,GAAa,IAAI,EAAE,MAAM,GAAa,IAAI,CAAC;IACrD,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;QACb,MAAM,GAAG,IAAI,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC;QAC1D,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAChB,EAAE,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,MAAM,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAC,CAAC;IAC5D,CAAC;IACD,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;QACb,MAAM,GAAG,IAAI,QAAQ,CAAC,UAAU,EAAE,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC;QAC3D,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAChB,EAAE,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,SAAS,EAAE,MAAM,EAAE,aAAa,CAAC,CAAC,CAAC;IAC9D,CAAC;IACD,IAAI,MAAM,GAAG,IAAI,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IAChC,MAAM,CAAC,KAAK,EAAE,CAAC;IACf,MAAM,CAAC;QACH,UAAU,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,QAAQ,EAAE,EAAZ,CAAY,CAAC;QAC5D,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,GAAG,YAAY;QAC3E,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,QAAQ,EAAE,GAAG,aAAa;KAChF,CAAC;AACN,CAAC;AAhCD,kEAgCC","sourcesContent":["    export class PositionStats {\r\n        AB: number = 0;\r\n        AD: number = 0;\r\n        A2: number = 0;\r\n\r\n        constructor(public scale: number) {}\r\n\r\n        addVariable(v: Variable): void {\r\n            var ai = this.scale / v.scale;\r\n            var bi = v.offset / v.scale;\r\n            var wi = v.weight;\r\n            this.AB += wi * ai * bi;\r\n            this.AD += wi * ai * v.desiredPosition;\r\n            this.A2 += wi * ai * ai;\r\n        }\r\n\r\n        getPosn(): number {\r\n            return (this.AD - this.AB) / this.A2;\r\n        }\r\n    }\r\n\r\n    export class Constraint {\r\n        lm: number;\r\n        active: boolean = false;\r\n        unsatisfiable: boolean = false;\r\n\r\n        constructor(public left: Variable, public right: Variable, public gap: number, public equality: boolean = false) {\r\n            this.left = left;\r\n            this.right = right;\r\n            this.gap = gap;\r\n            this.equality = equality;\r\n        }\r\n\r\n        slack(): number {\r\n            return this.unsatisfiable ? Number.MAX_VALUE\r\n                : this.right.scale * this.right.position() - this.gap\r\n                - this.left.scale * this.left.position();\r\n        }\r\n    }\r\n\r\n    export class Variable {\r\n        offset: number = 0;\r\n        block: Block;\r\n        cIn: Constraint[];\r\n        cOut: Constraint[];\r\n\r\n        constructor(public desiredPosition: number, public weight: number = 1, public scale: number = 1) {}\r\n\r\n        dfdv(): number {\r\n            return 2.0 * this.weight * (this.position() - this.desiredPosition);\r\n        }\r\n\r\n        position(): number {\r\n            return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\r\n        }\r\n\r\n        // visit neighbours by active constraints within the same block\r\n        visitNeighbours(prev: Variable, f: (c: Constraint, next: Variable) => void ): void {\r\n            var ff = (c, next) => c.active && prev !== next && f(c, next);\r\n            this.cOut.forEach(c=> ff(c, c.right));\r\n            this.cIn.forEach(c=> ff(c, c.left));\r\n        }\r\n    }\r\n\r\n    export class Block {\r\n        vars: Variable[] = [];\r\n        posn: number;\r\n        ps: PositionStats;\r\n        blockInd: number;\r\n\r\n        constructor(v: Variable) {\r\n            v.offset = 0;\r\n            this.ps = new PositionStats(v.scale);\r\n            this.addVariable(v);\r\n        }\r\n\r\n        private addVariable(v: Variable): void {\r\n            v.block = this;\r\n            this.vars.push(v);\r\n            this.ps.addVariable(v);\r\n            this.posn = this.ps.getPosn();\r\n        }\r\n\r\n        // move the block where it needs to be to minimize cost\r\n        updateWeightedPosition(): void {\r\n            this.ps.AB = this.ps.AD = this.ps.A2 = 0;\r\n            for (var i = 0, n = this.vars.length; i < n; ++i)\r\n                this.ps.addVariable(this.vars[i]);\r\n            this.posn = this.ps.getPosn();\r\n        }\r\n\r\n        private compute_lm(v: Variable, u: Variable, postAction: (c: Constraint)=>void): number {\r\n            var dfdv = v.dfdv();\r\n            v.visitNeighbours(u, (c, next) => {\r\n                var _dfdv = this.compute_lm(next, v, postAction);\r\n                if (next === c.right) {\r\n                    dfdv += _dfdv * c.left.scale;\r\n                    c.lm = _dfdv;\r\n                } else {\r\n                    dfdv += _dfdv * c.right.scale;\r\n                    c.lm = -_dfdv;\r\n                }\r\n                postAction(c);\r\n            });\r\n            return dfdv / v.scale;\r\n        }\r\n\r\n        private populateSplitBlock(v: Variable, prev: Variable): void {\r\n            v.visitNeighbours(prev, (c, next) => {\r\n                next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\r\n                this.addVariable(next);\r\n                this.populateSplitBlock(next, v);\r\n            });\r\n        }\r\n\r\n        // traverse the active constraint tree applying visit to each active constraint\r\n        traverse(visit: (c: Constraint) => any, acc: any[], v: Variable = this.vars[0], prev: Variable=null) {\r\n            v.visitNeighbours(prev, (c, next) => {\r\n                acc.push(visit(c));\r\n                this.traverse(visit, acc, next, v);\r\n            });\r\n        }\r\n\r\n        // calculate lagrangian multipliers on constraints and\r\n        // find the active constraint in this block with the smallest lagrangian.\r\n        // if the lagrangian is negative, then the constraint is a split candidate.\r\n        findMinLM(): Constraint {\r\n            var m: Constraint = null;\r\n            this.compute_lm(this.vars[0], null, c=> {\r\n                if (!c.equality && (m === null || c.lm < m.lm)) m = c;\r\n            });\r\n            return m;\r\n        }\r\n\r\n        private findMinLMBetween(lv: Variable, rv: Variable): Constraint {\r\n            this.compute_lm(lv, null, () => {});\r\n            var m = null;\r\n            this.findPath(lv, null, rv, (c, next)=> {\r\n                if (!c.equality && c.right === next && (m === null || c.lm < m.lm)) m = c;\r\n            });\r\n            return m;\r\n        }\r\n\r\n        private findPath(v: Variable, prev: Variable, to: Variable, visit: (c: Constraint, next:Variable)=>void): boolean {\r\n            var endFound = false;\r\n            v.visitNeighbours(prev, (c, next) => {\r\n                if (!endFound && (next === to || this.findPath(next, v, to, visit)))\r\n                {\r\n                    endFound = true;\r\n                    visit(c, next);\r\n                }\r\n            });\r\n            return endFound;\r\n        }\r\n\r\n        // Search active constraint tree from u to see if there is a directed path to v.\r\n        // Returns true if path is found.\r\n        isActiveDirectedPathBetween(u: Variable, v: Variable) : boolean {\r\n            if (u === v) return true;\r\n            var i = u.cOut.length;\r\n            while(i--) {\r\n                var c = u.cOut[i];\r\n                if (c.active && this.isActiveDirectedPathBetween(c.right, v))\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // split the block into two by deactivating the specified constraint\r\n        static split(c: Constraint): Block[]{\r\n/* DEBUG\r\n            console.log(\"split on \" + c);\r\n            console.assert(c.active, \"attempt to split on inactive constraint\");\r\nDEBUG */\r\n            c.active = false;\r\n            return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\r\n        }\r\n\r\n        private static createSplitBlock(startVar: Variable): Block {\r\n            var b = new Block(startVar);\r\n            b.populateSplitBlock(startVar, null);\r\n            return b;\r\n        }\r\n\r\n        // find a split point somewhere between the specified variables\r\n        splitBetween(vl: Variable, vr: Variable): { constraint: Constraint; lb: Block; rb: Block } {\r\n/* DEBUG\r\n            console.assert(vl.block === this);\r\n            console.assert(vr.block === this);\r\nDEBUG */\r\n            var c = this.findMinLMBetween(vl, vr);\r\n            if (c !== null) {\r\n                var bs = Block.split(c);\r\n                return { constraint: c, lb: bs[0], rb: bs[1] };\r\n            }\r\n            // couldn't find a split point - for example the active path is all equality constraints\r\n            return null;\r\n        }\r\n\r\n        mergeAcross(b: Block, c: Constraint, dist: number): void {\r\n            c.active = true;\r\n            for (var i = 0, n = b.vars.length; i < n; ++i) {\r\n                var v = b.vars[i];\r\n                v.offset += dist;\r\n                this.addVariable(v);\r\n            }\r\n            this.posn = this.ps.getPosn();\r\n        }\r\n\r\n        cost(): number {\r\n            var sum = 0, i = this.vars.length;\r\n            while (i--) {\r\n                var v = this.vars[i],\r\n                    d = v.position() - v.desiredPosition;\r\n                sum += d * d * v.weight;\r\n            }\r\n            return sum;\r\n        }\r\n\r\n/* DEBUG\r\n        toString(): string {\r\n            var cs = [];\r\n            this.traverse(c=> c.toString() + \"\\n\", cs)\r\n            return \"b\"+this.blockInd + \"@\" + this.posn + \": vars=\" + this.vars.map(v=> v.toString()+\":\"+v.offset) + \";\\n cons=\\n\" + cs;\r\n        }\r\nDEBUG */\r\n    }\r\n\r\n    export class Blocks {\r\n        private list: Block[];\r\n\r\n        constructor(public vs: Variable[]) {\r\n            var n = vs.length;\r\n            this.list = new Array(n);\r\n            while (n--) {\r\n                var b = new Block(vs[n]);\r\n                this.list[n] = b;\r\n                b.blockInd = n;\r\n            }\r\n        }\r\n\r\n        cost(): number {\r\n            var sum = 0, i = this.list.length;\r\n            while (i--) sum += this.list[i].cost();\r\n            return sum;\r\n        }\r\n\r\n        insert(b: Block) {\r\n/* DEBUG\r\n            console.assert(!this.contains(b), \"blocks error: tried to reinsert block \" + b.blockInd)\r\nDEBUG */\r\n            b.blockInd = this.list.length;\r\n            this.list.push(b);\r\n/* DEBUG\r\n            console.log(\"insert block: \" + b.blockInd);\r\n            this.contains(b);\r\nDEBUG */\r\n        }\r\n\r\n        remove(b: Block) {\r\n/* DEBUG\r\n            console.log(\"remove block: \" + b.blockInd);\r\n            console.assert(this.contains(b));\r\nDEBUG */\r\n            var last = this.list.length - 1;\r\n            var swapBlock = this.list[last];\r\n            this.list.length = last;\r\n            if (b !== swapBlock) {\r\n                this.list[b.blockInd] = swapBlock;\r\n                swapBlock.blockInd = b.blockInd;\r\n/* DEBUG\r\n                console.assert(this.contains(swapBlock));\r\nDEBUG */\r\n            }\r\n        }\r\n\r\n        // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger\r\n        // and deleting the smaller.\r\n        merge(c: Constraint): void {\r\n            var l = c.left.block, r = c.right.block;\r\n/* DEBUG\r\n            console.assert(l!==r, \"attempt to merge within the same block\");\r\nDEBUG */\r\n            var dist = c.right.offset - c.left.offset - c.gap;\r\n            if (l.vars.length < r.vars.length) {\r\n                r.mergeAcross(l, c, dist);\r\n                this.remove(l);\r\n            } else {\r\n                l.mergeAcross(r, c, -dist);\r\n                this.remove(r);\r\n            }\r\n/* DEBUG\r\n            console.assert(Math.abs(c.slack()) < 1e-6, \"Error: Constraint should be at equality after merge!\");\r\n            console.log(\"merged on \" + c);\r\nDEBUG */\r\n        }\r\n\r\n        forEach(f: (b: Block, i: number) => void ) {\r\n            this.list.forEach(f);\r\n        }\r\n\r\n        // useful, for example, after variable desired positions change.\r\n        updateBlockPositions(): void {\r\n            this.list.forEach(b=> b.updateWeightedPosition());\r\n        }\r\n\r\n        // split each block across its constraint with the minimum lagrangian\r\n        split(inactive: Constraint[]): void {\r\n            this.updateBlockPositions();\r\n            this.list.forEach(b=> {\r\n                var v = b.findMinLM();\r\n                if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\r\n                    b = v.left.block;\r\n                    Block.split(v).forEach(nb=>this.insert(nb));\r\n                    this.remove(b);\r\n                    inactive.push(v);\r\n/* DEBUG\r\n                    console.assert(this.contains(v.left.block));\r\n                    console.assert(this.contains(v.right.block));\r\nDEBUG */\r\n                }\r\n            });\r\n        }\r\n\r\n/* DEBUG\r\n        // checks b is in the block, and does a sanity check over list index integrity\r\n        contains(b: Block): boolean {\r\n            var result = false;\r\n            this.list.forEach((bb, i) => {\r\n                if (bb.blockInd !== i) {\r\n                    console.error(\"blocks error, blockInd \" + b.blockInd + \" found at \" + i);\r\n                    return false;\r\n                }\r\n                result = result || b === bb;\r\n            });\r\n            return result;\r\n        }\r\n\r\n        toString(): string {\r\n            return this.list.toString();\r\n        }\r\nDEBUG */\r\n    }\r\n\r\n    export class Solver {\r\n        bs: Blocks;\r\n        inactive: Constraint[];\r\n\r\n        static LAGRANGIAN_TOLERANCE = -1e-4;\r\n        static ZERO_UPPERBOUND = -1e-10;\r\n\r\n        constructor(public vs: Variable[], public cs: Constraint[]) {\r\n            this.vs = vs;\r\n            vs.forEach(v => {\r\n                v.cIn = [], v.cOut = [];\r\n/* DEBUG\r\n                v.toString = () => \"v\" + vs.indexOf(v);\r\nDEBUG */\r\n            });\r\n            this.cs = cs;\r\n            cs.forEach(c => {\r\n                c.left.cOut.push(c);\r\n                c.right.cIn.push(c);\r\n/* DEBUG\r\n                c.toString = () => c.left + \"+\" + c.gap + \"<=\" + c.right + \" slack=\" + c.slack() + \" active=\" + c.active;\r\nDEBUG */\r\n            });\r\n            this.inactive = cs.map(c=> { c.active = false; return c; });\r\n            this.bs = null;\r\n        }\r\n\r\n        cost(): number {\r\n            return this.bs.cost();\r\n        }\r\n\r\n        // set starting positions without changing desired positions.\r\n        // Note: it throws away any previous block structure.\r\n        setStartingPositions(ps: number[]): void {\r\n            this.inactive = this.cs.map(c=> { c.active = false; return c; });\r\n            this.bs = new Blocks(this.vs);\r\n            this.bs.forEach((b, i) => b.posn = ps[i]);\r\n        }\r\n\r\n        setDesiredPositions(ps: number[]): void {\r\n            this.vs.forEach((v, i) => v.desiredPosition = ps[i]);\r\n        }\r\n\r\n/* DEBUG\r\n        private getId(v: Variable): number {\r\n            return this.vs.indexOf(v);\r\n        }\r\n\r\n        // sanity check of the index integrity of the inactive list\r\n        checkInactive(): void {\r\n            var inactiveCount = 0;\r\n            this.cs.forEach(c=> {\r\n                var i = this.inactive.indexOf(c);\r\n                console.assert(!c.active && i >= 0 || c.active && i < 0, \"constraint should be in the inactive list if it is not active: \" + c);\r\n                if (i >= 0) {\r\n                    inactiveCount++;\r\n                } else {\r\n                    console.assert(c.active, \"inactive constraint not found in inactive list: \" + c);\r\n                }\r\n            });\r\n            console.assert(inactiveCount === this.inactive.length, inactiveCount + \" inactive constraints found, \" + this.inactive.length + \"in inactive list\");\r\n        }\r\n        // after every call to satisfy the following should check should pass\r\n        checkSatisfied(): void {\r\n            this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, \"Error: Unsatisfied constraint! \"+c));\r\n        }\r\nDEBUG */\r\n\r\n        private mostViolated(): Constraint {\r\n            var minSlack = Number.MAX_VALUE,\r\n                v: Constraint = null,\r\n                l = this.inactive,\r\n                n = l.length,\r\n                deletePoint = n;\r\n            for (var i = 0; i < n; ++i) {\r\n                var c = l[i];\r\n                if (c.unsatisfiable) continue;\r\n                var slack = c.slack();\r\n                if (c.equality || slack < minSlack) {\r\n                    minSlack = slack;\r\n                    v = c;\r\n                    deletePoint = i;\r\n                    if (c.equality) break;\r\n                }\r\n            }\r\n            if (deletePoint !== n &&\r\n                (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality))\r\n            {\r\n                l[deletePoint] = l[n - 1];\r\n                l.length = n - 1;\r\n            }\r\n            return v;\r\n        }\r\n\r\n        // satisfy constraints by building block structure over violated constraints\r\n        // and moving the blocks to their desired positions\r\n        satisfy(): void {\r\n            if (this.bs == null) {\r\n                this.bs = new Blocks(this.vs);\r\n            }\r\n/* DEBUG\r\n            console.log(\"satisfy: \" + this.bs);\r\nDEBUG */\r\n            this.bs.split(this.inactive);\r\n            var v: Constraint = null;\r\n            while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\r\n                var lb = v.left.block, rb = v.right.block;\r\n/* DEBUG\r\n                console.log(\"most violated is: \" + v);\r\n                this.bs.contains(lb);\r\n                this.bs.contains(rb);\r\nDEBUG */\r\n                if (lb !== rb) {\r\n                    this.bs.merge(v);\r\n                } else {\r\n                    if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\r\n                        // cycle found!\r\n                        v.unsatisfiable = true;\r\n                        continue;\r\n                    }\r\n                    // constraint is within block, need to split first\r\n                    var split = lb.splitBetween(v.left, v.right);\r\n                    if (split !== null) {\r\n                        this.bs.insert(split.lb);\r\n                        this.bs.insert(split.rb);\r\n                        this.bs.remove(lb);\r\n                        this.inactive.push(split.constraint);\r\n                    } else {\r\n/* DEBUG\r\n                        console.log(\"unsatisfiable constraint found\");\r\nDEBUG */\r\n                        v.unsatisfiable = true;\r\n                        continue;\r\n                    }\r\n                    if (v.slack() >= 0) {\r\n/* DEBUG\r\n                        console.log(\"violated constraint indirectly satisfied: \" + v);\r\nDEBUG */\r\n                        // v was satisfied by the above split!\r\n                        this.inactive.push(v);\r\n                    } else {\r\n/* DEBUG\r\n                        console.log(\"merge after split:\");\r\nDEBUG */\r\n                        this.bs.merge(v);\r\n                    }\r\n                }\r\n/* DEBUG\r\n                this.bs.contains(v.left.block);\r\n                this.bs.contains(v.right.block);\r\n                this.checkInactive();\r\nDEBUG */\r\n            }\r\n/* DEBUG\r\n            this.checkSatisfied();\r\nDEBUG */\r\n        }\r\n\r\n        // repeatedly build and split block structure until we converge to an optimal solution\r\n        solve(): number {\r\n            this.satisfy();\r\n            var lastcost = Number.MAX_VALUE, cost = this.bs.cost();\r\n            while (Math.abs(lastcost - cost) > 0.0001) {\r\n                this.satisfy();\r\n                lastcost = cost;\r\n                cost = this.bs.cost();\r\n            }\r\n            return cost;\r\n        }\r\n    }\r\n    /**\r\n      * Remove overlap between spans while keeping their centers as close as possible to the specified desiredCenters.\r\n      * Lower and upper bounds will be respected if the spans physically fit between them\r\n      * (otherwise they'll be moved and their new position returned).\r\n      * If no upper/lower bound is specified then the bounds of the moved spans will be returned.\r\n      * returns a new center for each span.\r\n      */\r\n    export function removeOverlapInOneDimension(spans: { size: number, desiredCenter: number }[], lowerBound?: number, upperBound?: number)\r\n        : { newCenters: number[], lowerBound: number, upperBound: number }\r\n    {\r\n        const vs: Variable[] = spans.map(s => new Variable(s.desiredCenter));\r\n        const cs: Constraint[] = [];\r\n        const n = spans.length;\r\n        for (var i = 0; i < n - 1; i++) {\r\n            const left = spans[i], right = spans[i + 1];\r\n            cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));\r\n        }\r\n        const leftMost = vs[0],\r\n            rightMost = vs[n - 1],\r\n            leftMostSize = spans[0].size / 2,\r\n            rightMostSize = spans[n - 1].size / 2;\r\n        let vLower: Variable = null, vUpper: Variable = null;\r\n        if (lowerBound) {\r\n            vLower = new Variable(lowerBound, leftMost.weight * 1000);\r\n            vs.push(vLower);\r\n            cs.push(new Constraint(vLower, leftMost, leftMostSize));\r\n        }\r\n        if (upperBound) {\r\n            vUpper = new Variable(upperBound, rightMost.weight * 1000);\r\n            vs.push(vUpper);\r\n            cs.push(new Constraint(rightMost, vUpper, rightMostSize));\r\n        }\r\n        var solver = new Solver(vs, cs);\r\n        solver.solve();\r\n        return {\r\n            newCenters: vs.slice(0, spans.length).map(v => v.position()),\r\n            lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,\r\n            upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize\r\n        };\r\n    }\r\n"]}},"hash":"8d3434cb45411d57582f0d9c0fb7f624","cacheData":{"env":{}}}