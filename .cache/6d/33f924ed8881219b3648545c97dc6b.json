{"id":"node_modules/webcola/dist/src/layout.js","dependencies":[{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/layout.js.map","includedInParent":true,"mtime":1517462217000},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/WebCola/src/layout.ts","includedInParent":true,"mtime":1516884256000},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/package.json","includedInParent":true,"mtime":1550967406043},{"name":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/package.json","includedInParent":true,"mtime":1550967405642},{"name":"./powergraph","loc":{"line":3,"column":25},"parent":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/layout.js","resolved":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/powergraph.js"},{"name":"./linklengths","loc":{"line":4,"column":28},"parent":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/layout.js","resolved":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/linklengths.js"},{"name":"./descent","loc":{"line":5,"column":24},"parent":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/layout.js","resolved":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/descent.js"},{"name":"./rectangle","loc":{"line":6,"column":26},"parent":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/layout.js","resolved":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/rectangle.js"},{"name":"./shortestpaths","loc":{"line":7,"column":30},"parent":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/layout.js","resolved":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/shortestpaths.js"},{"name":"./geom","loc":{"line":8,"column":21},"parent":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/layout.js","resolved":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/geom.js"},{"name":"./handledisconnected","loc":{"line":9,"column":35},"parent":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/layout.js","resolved":"/Users/reza/Documents/Meteor/Force Directed Graph/Graph/node_modules/webcola/dist/src/handledisconnected.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar powergraph = require(\"./powergraph\");\r\nvar linklengths_1 = require(\"./linklengths\");\r\nvar descent_1 = require(\"./descent\");\r\nvar rectangle_1 = require(\"./rectangle\");\r\nvar shortestpaths_1 = require(\"./shortestpaths\");\r\nvar geom_1 = require(\"./geom\");\r\nvar handledisconnected_1 = require(\"./handledisconnected\");\r\nvar EventType;\r\n(function (EventType) {\r\n    EventType[EventType[\"start\"] = 0] = \"start\";\r\n    EventType[EventType[\"tick\"] = 1] = \"tick\";\r\n    EventType[EventType[\"end\"] = 2] = \"end\";\r\n})(EventType = exports.EventType || (exports.EventType = {}));\r\n;\r\nfunction isGroup(g) {\r\n    return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\r\n}\r\nvar Layout = (function () {\r\n    function Layout() {\r\n        var _this = this;\r\n        this._canvasSize = [1, 1];\r\n        this._linkDistance = 20;\r\n        this._defaultNodeSize = 10;\r\n        this._linkLengthCalculator = null;\r\n        this._linkType = null;\r\n        this._avoidOverlaps = false;\r\n        this._handleDisconnected = true;\r\n        this._running = false;\r\n        this._nodes = [];\r\n        this._groups = [];\r\n        this._rootGroup = null;\r\n        this._links = [];\r\n        this._constraints = [];\r\n        this._distanceMatrix = null;\r\n        this._descent = null;\r\n        this._directedLinkConstraints = null;\r\n        this._threshold = 0.01;\r\n        this._visibilityGraph = null;\r\n        this._groupCompactness = 1e-6;\r\n        this.event = null;\r\n        this.linkAccessor = {\r\n            getSourceIndex: Layout.getSourceIndex,\r\n            getTargetIndex: Layout.getTargetIndex,\r\n            setLength: Layout.setLinkLength,\r\n            getType: function (l) { return typeof _this._linkType === \"function\" ? _this._linkType(l) : 0; }\r\n        };\r\n    }\r\n    Layout.prototype.on = function (e, listener) {\r\n        if (!this.event)\r\n            this.event = {};\r\n        if (typeof e === 'string') {\r\n            this.event[EventType[e]] = listener;\r\n        }\r\n        else {\r\n            this.event[e] = listener;\r\n        }\r\n        return this;\r\n    };\r\n    Layout.prototype.trigger = function (e) {\r\n        if (this.event && typeof this.event[e.type] !== 'undefined') {\r\n            this.event[e.type](e);\r\n        }\r\n    };\r\n    Layout.prototype.kick = function () {\r\n        while (!this.tick())\r\n            ;\r\n    };\r\n    Layout.prototype.tick = function () {\r\n        if (this._alpha < this._threshold) {\r\n            this._running = false;\r\n            this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });\r\n            return true;\r\n        }\r\n        var n = this._nodes.length, m = this._links.length;\r\n        var o, i;\r\n        this._descent.locks.clear();\r\n        for (i = 0; i < n; ++i) {\r\n            o = this._nodes[i];\r\n            if (o.fixed) {\r\n                if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\r\n                    o.px = o.x;\r\n                    o.py = o.y;\r\n                }\r\n                var p = [o.px, o.py];\r\n                this._descent.locks.add(i, p);\r\n            }\r\n        }\r\n        var s1 = this._descent.rungeKutta();\r\n        if (s1 === 0) {\r\n            this._alpha = 0;\r\n        }\r\n        else if (typeof this._lastStress !== 'undefined') {\r\n            this._alpha = s1;\r\n        }\r\n        this._lastStress = s1;\r\n        this.updateNodePositions();\r\n        this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });\r\n        return false;\r\n    };\r\n    Layout.prototype.updateNodePositions = function () {\r\n        var x = this._descent.x[0], y = this._descent.x[1];\r\n        var o, i = this._nodes.length;\r\n        while (i--) {\r\n            o = this._nodes[i];\r\n            o.x = x[i];\r\n            o.y = y[i];\r\n        }\r\n    };\r\n    Layout.prototype.nodes = function (v) {\r\n        if (!v) {\r\n            if (this._nodes.length === 0 && this._links.length > 0) {\r\n                var n = 0;\r\n                this._links.forEach(function (l) {\r\n                    n = Math.max(n, l.source, l.target);\r\n                });\r\n                this._nodes = new Array(++n);\r\n                for (var i = 0; i < n; ++i) {\r\n                    this._nodes[i] = {};\r\n                }\r\n            }\r\n            return this._nodes;\r\n        }\r\n        this._nodes = v;\r\n        return this;\r\n    };\r\n    Layout.prototype.groups = function (x) {\r\n        var _this = this;\r\n        if (!x)\r\n            return this._groups;\r\n        this._groups = x;\r\n        this._rootGroup = {};\r\n        this._groups.forEach(function (g) {\r\n            if (typeof g.padding === \"undefined\")\r\n                g.padding = 1;\r\n            if (typeof g.leaves !== \"undefined\") {\r\n                g.leaves.forEach(function (v, i) {\r\n                    if (typeof v === 'number')\r\n                        (g.leaves[i] = _this._nodes[v]).parent = g;\r\n                });\r\n            }\r\n            if (typeof g.groups !== \"undefined\") {\r\n                g.groups.forEach(function (gi, i) {\r\n                    if (typeof gi === 'number')\r\n                        (g.groups[i] = _this._groups[gi]).parent = g;\r\n                });\r\n            }\r\n        });\r\n        this._rootGroup.leaves = this._nodes.filter(function (v) { return typeof v.parent === 'undefined'; });\r\n        this._rootGroup.groups = this._groups.filter(function (g) { return typeof g.parent === 'undefined'; });\r\n        return this;\r\n    };\r\n    Layout.prototype.powerGraphGroups = function (f) {\r\n        var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\r\n        this.groups(g.groups);\r\n        f(g);\r\n        return this;\r\n    };\r\n    Layout.prototype.avoidOverlaps = function (v) {\r\n        if (!arguments.length)\r\n            return this._avoidOverlaps;\r\n        this._avoidOverlaps = v;\r\n        return this;\r\n    };\r\n    Layout.prototype.handleDisconnected = function (v) {\r\n        if (!arguments.length)\r\n            return this._handleDisconnected;\r\n        this._handleDisconnected = v;\r\n        return this;\r\n    };\r\n    Layout.prototype.flowLayout = function (axis, minSeparation) {\r\n        if (!arguments.length)\r\n            axis = 'y';\r\n        this._directedLinkConstraints = {\r\n            axis: axis,\r\n            getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation; } : minSeparation\r\n        };\r\n        return this;\r\n    };\r\n    Layout.prototype.links = function (x) {\r\n        if (!arguments.length)\r\n            return this._links;\r\n        this._links = x;\r\n        return this;\r\n    };\r\n    Layout.prototype.constraints = function (c) {\r\n        if (!arguments.length)\r\n            return this._constraints;\r\n        this._constraints = c;\r\n        return this;\r\n    };\r\n    Layout.prototype.distanceMatrix = function (d) {\r\n        if (!arguments.length)\r\n            return this._distanceMatrix;\r\n        this._distanceMatrix = d;\r\n        return this;\r\n    };\r\n    Layout.prototype.size = function (x) {\r\n        if (!x)\r\n            return this._canvasSize;\r\n        this._canvasSize = x;\r\n        return this;\r\n    };\r\n    Layout.prototype.defaultNodeSize = function (x) {\r\n        if (!x)\r\n            return this._defaultNodeSize;\r\n        this._defaultNodeSize = x;\r\n        return this;\r\n    };\r\n    Layout.prototype.groupCompactness = function (x) {\r\n        if (!x)\r\n            return this._groupCompactness;\r\n        this._groupCompactness = x;\r\n        return this;\r\n    };\r\n    Layout.prototype.linkDistance = function (x) {\r\n        if (!x) {\r\n            return this._linkDistance;\r\n        }\r\n        this._linkDistance = typeof x === \"function\" ? x : +x;\r\n        this._linkLengthCalculator = null;\r\n        return this;\r\n    };\r\n    Layout.prototype.linkType = function (f) {\r\n        this._linkType = f;\r\n        return this;\r\n    };\r\n    Layout.prototype.convergenceThreshold = function (x) {\r\n        if (!x)\r\n            return this._threshold;\r\n        this._threshold = typeof x === \"function\" ? x : +x;\r\n        return this;\r\n    };\r\n    Layout.prototype.alpha = function (x) {\r\n        if (!arguments.length)\r\n            return this._alpha;\r\n        else {\r\n            x = +x;\r\n            if (this._alpha) {\r\n                if (x > 0)\r\n                    this._alpha = x;\r\n                else\r\n                    this._alpha = 0;\r\n            }\r\n            else if (x > 0) {\r\n                if (!this._running) {\r\n                    this._running = true;\r\n                    this.trigger({ type: EventType.start, alpha: this._alpha = x });\r\n                    this.kick();\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n    };\r\n    Layout.prototype.getLinkLength = function (link) {\r\n        return typeof this._linkDistance === \"function\" ? +(this._linkDistance(link)) : this._linkDistance;\r\n    };\r\n    Layout.setLinkLength = function (link, length) {\r\n        link.length = length;\r\n    };\r\n    Layout.prototype.getLinkType = function (link) {\r\n        return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\r\n    };\r\n    Layout.prototype.symmetricDiffLinkLengths = function (idealLength, w) {\r\n        var _this = this;\r\n        if (w === void 0) { w = 1; }\r\n        this.linkDistance(function (l) { return idealLength * l.length; });\r\n        this._linkLengthCalculator = function () { return linklengths_1.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w); };\r\n        return this;\r\n    };\r\n    Layout.prototype.jaccardLinkLengths = function (idealLength, w) {\r\n        var _this = this;\r\n        if (w === void 0) { w = 1; }\r\n        this.linkDistance(function (l) { return idealLength * l.length; });\r\n        this._linkLengthCalculator = function () { return linklengths_1.jaccardLinkLengths(_this._links, _this.linkAccessor, w); };\r\n        return this;\r\n    };\r\n    Layout.prototype.start = function (initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning) {\r\n        var _this = this;\r\n        if (initialUnconstrainedIterations === void 0) { initialUnconstrainedIterations = 0; }\r\n        if (initialUserConstraintIterations === void 0) { initialUserConstraintIterations = 0; }\r\n        if (initialAllConstraintsIterations === void 0) { initialAllConstraintsIterations = 0; }\r\n        if (gridSnapIterations === void 0) { gridSnapIterations = 0; }\r\n        if (keepRunning === void 0) { keepRunning = true; }\r\n        var i, j, n = this.nodes().length, N = n + 2 * this._groups.length, m = this._links.length, w = this._canvasSize[0], h = this._canvasSize[1];\r\n        var x = new Array(N), y = new Array(N);\r\n        var G = null;\r\n        var ao = this._avoidOverlaps;\r\n        this._nodes.forEach(function (v, i) {\r\n            v.index = i;\r\n            if (typeof v.x === 'undefined') {\r\n                v.x = w / 2, v.y = h / 2;\r\n            }\r\n            x[i] = v.x, y[i] = v.y;\r\n        });\r\n        if (this._linkLengthCalculator)\r\n            this._linkLengthCalculator();\r\n        var distances;\r\n        if (this._distanceMatrix) {\r\n            distances = this._distanceMatrix;\r\n        }\r\n        else {\r\n            distances = (new shortestpaths_1.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, function (l) { return _this.getLinkLength(l); })).DistanceMatrix();\r\n            G = descent_1.Descent.createSquareMatrix(N, function () { return 2; });\r\n            this._links.forEach(function (l) {\r\n                if (typeof l.source == \"number\")\r\n                    l.source = _this._nodes[l.source];\r\n                if (typeof l.target == \"number\")\r\n                    l.target = _this._nodes[l.target];\r\n            });\r\n            this._links.forEach(function (e) {\r\n                var u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);\r\n                G[u][v] = G[v][u] = e.weight || 1;\r\n            });\r\n        }\r\n        var D = descent_1.Descent.createSquareMatrix(N, function (i, j) {\r\n            return distances[i][j];\r\n        });\r\n        if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\r\n            var i = n;\r\n            var addAttraction = function (i, j, strength, idealDistance) {\r\n                G[i][j] = G[j][i] = strength;\r\n                D[i][j] = D[j][i] = idealDistance;\r\n            };\r\n            this._groups.forEach(function (g) {\r\n                addAttraction(i, i + 1, _this._groupCompactness, 0.1);\r\n                x[i] = 0, y[i++] = 0;\r\n                x[i] = 0, y[i++] = 0;\r\n            });\r\n        }\r\n        else\r\n            this._rootGroup = { leaves: this._nodes, groups: [] };\r\n        var curConstraints = this._constraints || [];\r\n        if (this._directedLinkConstraints) {\r\n            this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;\r\n            curConstraints = curConstraints.concat(linklengths_1.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, (this.linkAccessor)));\r\n        }\r\n        this.avoidOverlaps(false);\r\n        this._descent = new descent_1.Descent([x, y], D);\r\n        this._descent.locks.clear();\r\n        for (var i = 0; i < n; ++i) {\r\n            var o = this._nodes[i];\r\n            if (o.fixed) {\r\n                o.px = o.x;\r\n                o.py = o.y;\r\n                var p = [o.x, o.y];\r\n                this._descent.locks.add(i, p);\r\n            }\r\n        }\r\n        this._descent.threshold = this._threshold;\r\n        this.initialLayout(initialUnconstrainedIterations, x, y);\r\n        if (curConstraints.length > 0)\r\n            this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\r\n        this._descent.run(initialUserConstraintIterations);\r\n        this.separateOverlappingComponents(w, h);\r\n        this.avoidOverlaps(ao);\r\n        if (ao) {\r\n            this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\r\n            this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\r\n            this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });\r\n        }\r\n        this._descent.G = G;\r\n        this._descent.run(initialAllConstraintsIterations);\r\n        if (gridSnapIterations) {\r\n            this._descent.snapStrength = 1000;\r\n            this._descent.snapGridSize = this._nodes[0].width;\r\n            this._descent.numGridSnapNodes = n;\r\n            this._descent.scaleSnapByMaxH = n != N;\r\n            var G0 = descent_1.Descent.createSquareMatrix(N, function (i, j) {\r\n                if (i >= n || j >= n)\r\n                    return G[i][j];\r\n                return 0;\r\n            });\r\n            this._descent.G = G0;\r\n            this._descent.run(gridSnapIterations);\r\n        }\r\n        this.updateNodePositions();\r\n        this.separateOverlappingComponents(w, h);\r\n        return keepRunning ? this.resume() : this;\r\n    };\r\n    Layout.prototype.initialLayout = function (iterations, x, y) {\r\n        if (this._groups.length > 0 && iterations > 0) {\r\n            var n = this._nodes.length;\r\n            var edges = this._links.map(function (e) { return ({ source: e.source.index, target: e.target.index }); });\r\n            var vs = this._nodes.map(function (v) { return ({ index: v.index }); });\r\n            this._groups.forEach(function (g, i) {\r\n                vs.push({ index: g.index = n + i });\r\n            });\r\n            this._groups.forEach(function (g, i) {\r\n                if (typeof g.leaves !== 'undefined')\r\n                    g.leaves.forEach(function (v) { return edges.push({ source: g.index, target: v.index }); });\r\n                if (typeof g.groups !== 'undefined')\r\n                    g.groups.forEach(function (gg) { return edges.push({ source: g.index, target: gg.index }); });\r\n            });\r\n            new Layout()\r\n                .size(this.size())\r\n                .nodes(vs)\r\n                .links(edges)\r\n                .avoidOverlaps(false)\r\n                .linkDistance(this.linkDistance())\r\n                .symmetricDiffLinkLengths(5)\r\n                .convergenceThreshold(1e-4)\r\n                .start(iterations, 0, 0, 0, false);\r\n            this._nodes.forEach(function (v) {\r\n                x[v.index] = vs[v.index].x;\r\n                y[v.index] = vs[v.index].y;\r\n            });\r\n        }\r\n        else {\r\n            this._descent.run(iterations);\r\n        }\r\n    };\r\n    Layout.prototype.separateOverlappingComponents = function (width, height) {\r\n        var _this = this;\r\n        if (!this._distanceMatrix && this._handleDisconnected) {\r\n            var x_1 = this._descent.x[0], y_1 = this._descent.x[1];\r\n            this._nodes.forEach(function (v, i) { v.x = x_1[i], v.y = y_1[i]; });\r\n            var graphs = handledisconnected_1.separateGraphs(this._nodes, this._links);\r\n            handledisconnected_1.applyPacking(graphs, width, height, this._defaultNodeSize);\r\n            this._nodes.forEach(function (v, i) {\r\n                _this._descent.x[0][i] = v.x, _this._descent.x[1][i] = v.y;\r\n                if (v.bounds) {\r\n                    v.bounds.setXCentre(v.x);\r\n                    v.bounds.setYCentre(v.y);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    Layout.prototype.resume = function () {\r\n        return this.alpha(0.1);\r\n    };\r\n    Layout.prototype.stop = function () {\r\n        return this.alpha(0);\r\n    };\r\n    Layout.prototype.prepareEdgeRouting = function (nodeMargin) {\r\n        if (nodeMargin === void 0) { nodeMargin = 0; }\r\n        this._visibilityGraph = new geom_1.TangentVisibilityGraph(this._nodes.map(function (v) {\r\n            return v.bounds.inflate(-nodeMargin).vertices();\r\n        }));\r\n    };\r\n    Layout.prototype.routeEdge = function (edge, ah, draw) {\r\n        if (ah === void 0) { ah = 5; }\r\n        var lineData = [];\r\n        var vg2 = new geom_1.TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }), port1 = { x: edge.source.x, y: edge.source.y }, port2 = { x: edge.target.x, y: edge.target.y }, start = vg2.addPoint(port1, edge.source.index), end = vg2.addPoint(port2, edge.target.index);\r\n        vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\r\n        if (typeof draw !== 'undefined') {\r\n            draw(vg2);\r\n        }\r\n        var sourceInd = function (e) { return e.source.id; }, targetInd = function (e) { return e.target.id; }, length = function (e) { return e.length(); }, spCalc = new shortestpaths_1.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length), shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\r\n        if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\r\n            var route = rectangle_1.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);\r\n            lineData = [route.sourceIntersection, route.arrowStart];\r\n        }\r\n        else {\r\n            var n = shortestPath.length - 2, p = vg2.V[shortestPath[n]].p, q = vg2.V[shortestPath[0]].p, lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\r\n            for (var i = n; i >= 0; --i)\r\n                lineData.push(vg2.V[shortestPath[i]].p);\r\n            lineData.push(rectangle_1.makeEdgeTo(q, edge.target.innerBounds, ah));\r\n        }\r\n        return lineData;\r\n    };\r\n    Layout.getSourceIndex = function (e) {\r\n        return typeof e.source === 'number' ? e.source : e.source.index;\r\n    };\r\n    Layout.getTargetIndex = function (e) {\r\n        return typeof e.target === 'number' ? e.target : e.target.index;\r\n    };\r\n    Layout.linkId = function (e) {\r\n        return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\r\n    };\r\n    Layout.dragStart = function (d) {\r\n        if (isGroup(d)) {\r\n            Layout.storeOffset(d, Layout.dragOrigin(d));\r\n        }\r\n        else {\r\n            Layout.stopNode(d);\r\n            d.fixed |= 2;\r\n        }\r\n    };\r\n    Layout.stopNode = function (v) {\r\n        v.px = v.x;\r\n        v.py = v.y;\r\n    };\r\n    Layout.storeOffset = function (d, origin) {\r\n        if (typeof d.leaves !== 'undefined') {\r\n            d.leaves.forEach(function (v) {\r\n                v.fixed |= 2;\r\n                Layout.stopNode(v);\r\n                v._dragGroupOffsetX = v.x - origin.x;\r\n                v._dragGroupOffsetY = v.y - origin.y;\r\n            });\r\n        }\r\n        if (typeof d.groups !== 'undefined') {\r\n            d.groups.forEach(function (g) { return Layout.storeOffset(g, origin); });\r\n        }\r\n    };\r\n    Layout.dragOrigin = function (d) {\r\n        if (isGroup(d)) {\r\n            return {\r\n                x: d.bounds.cx(),\r\n                y: d.bounds.cy()\r\n            };\r\n        }\r\n        else {\r\n            return d;\r\n        }\r\n    };\r\n    Layout.drag = function (d, position) {\r\n        if (isGroup(d)) {\r\n            if (typeof d.leaves !== 'undefined') {\r\n                d.leaves.forEach(function (v) {\r\n                    d.bounds.setXCentre(position.x);\r\n                    d.bounds.setYCentre(position.y);\r\n                    v.px = v._dragGroupOffsetX + position.x;\r\n                    v.py = v._dragGroupOffsetY + position.y;\r\n                });\r\n            }\r\n            if (typeof d.groups !== 'undefined') {\r\n                d.groups.forEach(function (g) { return Layout.drag(g, position); });\r\n            }\r\n        }\r\n        else {\r\n            d.px = position.x;\r\n            d.py = position.y;\r\n        }\r\n    };\r\n    Layout.dragEnd = function (d) {\r\n        if (isGroup(d)) {\r\n            if (typeof d.leaves !== 'undefined') {\r\n                d.leaves.forEach(function (v) {\r\n                    Layout.dragEnd(v);\r\n                    delete v._dragGroupOffsetX;\r\n                    delete v._dragGroupOffsetY;\r\n                });\r\n            }\r\n            if (typeof d.groups !== 'undefined') {\r\n                d.groups.forEach(Layout.dragEnd);\r\n            }\r\n        }\r\n        else {\r\n            d.fixed &= ~6;\r\n        }\r\n    };\r\n    Layout.mouseOver = function (d) {\r\n        d.fixed |= 4;\r\n        d.px = d.x, d.py = d.y;\r\n    };\r\n    Layout.mouseOut = function (d) {\r\n        d.fixed &= ~4;\r\n    };\r\n    return Layout;\r\n}());\r\nexports.Layout = Layout;\r\n","map":{"version":3,"file":"layout.js","sourceRoot":"","sources":["../../WebCola/src/layout.ts"],"names":[],"mappings":"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","sourcesContent":["import * as powergraph from './powergraph'\r\nimport {LinkLengthAccessor, symmetricDiffLinkLengths, jaccardLinkLengths, generateDirectedEdgeConstraints} from './linklengths'\r\nimport {Descent} from './descent'\r\nimport {Rectangle, Projection, makeEdgeTo, makeEdgeBetween} from './rectangle'\r\nimport {Calculator} from './shortestpaths'\r\nimport {TangentVisibilityGraph, TVGPoint} from './geom'\r\nimport {separateGraphs, applyPacking} from './handledisconnected'\r\n    /**\r\n     * The layout process fires three events:\r\n     *  - start: layout iterations started\r\n     *  - tick: fired once per iteration, listen to this to animate\r\n     *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event\r\n     */\r\n    export enum EventType { start, tick, end };\r\n    export interface Event {\r\n        type: EventType;\r\n        alpha: number;\r\n        stress?: number;\r\n        listener?: () => void;\r\n    }\r\n    export interface InputNode {\r\n        /**\r\n         * index in nodes array, this is initialized by Layout.start()\r\n         */\r\n        index?: number;\r\n        /**\r\n         * x and y will be computed by layout as the Node's centroid\r\n         */\r\n        x?: number;\r\n        /**\r\n         * x and y will be computed by layout as the Node's centroid\r\n         */\r\n        y?: number;\r\n        /**\r\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\r\n         */\r\n        width?: number;\r\n        /**\r\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\r\n         */\r\n        height?: number;\r\n        /**\r\n         * selective bit mask.  !=0 means layout will not move.\r\n         */\r\n        fixed?: number;\r\n    }\r\n    export interface Node extends InputNode {\r\n      // Client-passed node may be missing these properties, which will be set\r\n      // upon ingestion\r\n      x: number;\r\n      y: number;\r\n    }\r\n\r\n    export interface Group {\r\n        bounds?: Rectangle;\r\n        leaves?: Node[];\r\n        groups?: Group[];\r\n        padding: number;\r\n    }\r\n\r\n    function isGroup(g: any): g is Group {\r\n        return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\r\n    }\r\n\r\n    export interface Link<NodeRefType> {\r\n        source: NodeRefType;\r\n        target: NodeRefType;\r\n\r\n        // ideal length the layout should try to achieve for this link\r\n        length?: number;\r\n\r\n        // how hard we should try to satisfy this link's ideal length\r\n        // must be in the range: 0 < weight <= 1\r\n        // if unspecified 1 is the default\r\n        weight?: number;\r\n    }\r\n\r\n    export type LinkNumericPropertyAccessor = (t: Link<Node | number>) => number;\r\n\r\n    export interface LinkLengthTypeAccessor extends LinkLengthAccessor<Link<Node | number>> {\r\n        getType: LinkNumericPropertyAccessor;\r\n    }\r\n    /**\r\n     * Main interface to cola layout.\r\n     * @class Layout\r\n     */\r\n    export class Layout {\r\n        private _canvasSize = [1, 1];\r\n        private _linkDistance: number | LinkNumericPropertyAccessor = 20;\r\n        private _defaultNodeSize: number = 10;\r\n        private _linkLengthCalculator = null;\r\n        private _linkType = null;\r\n        private _avoidOverlaps = false;\r\n        private _handleDisconnected = true;\r\n        private _alpha;\r\n        private _lastStress;\r\n        private _running = false;\r\n        private _nodes = [];\r\n        private _groups = [];\r\n        private _rootGroup = null;\r\n        private _links: Link<Node | number>[] = [];\r\n        private _constraints = [];\r\n        private _distanceMatrix = null;\r\n        private _descent: Descent = null;\r\n        private _directedLinkConstraints = null;\r\n        private _threshold = 0.01;\r\n        private _visibilityGraph = null;\r\n        private _groupCompactness = 1e-6;\r\n\r\n        // sub-class and override this property to replace with a more sophisticated eventing mechanism\r\n        protected event = null;\r\n\r\n        // subscribe a listener to an event\r\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\r\n        public on(e: EventType | string, listener: (event?: Event) => void): this {\r\n            // override me!\r\n            if (!this.event) this.event = {};\r\n            if (typeof e === 'string') {\r\n                this.event[EventType[e]] = listener;\r\n            } else {\r\n                this.event[e] = listener;\r\n            }\r\n            return this;\r\n        }\r\n\r\n        // a function that is notified of events like \"tick\"\r\n        // sub-classes can override this method to replace with a more sophisticated eventing mechanism\r\n        protected trigger(e: Event) {\r\n            if (this.event && typeof this.event[e.type] !== 'undefined') {\r\n                this.event[e.type](e);\r\n            }\r\n        }\r\n\r\n        // a function that kicks off the iteration tick loop\r\n        // it calls tick() repeatedly until tick returns true (is converged)\r\n        // subclass and override it with something fancier (e.g. dispatch tick on a timer)\r\n        protected kick(): void {\r\n            while (!this.tick());\r\n        }\r\n\r\n        /**\r\n         * iterate the layout.  Returns true when layout converged.\r\n         */\r\n        protected tick(): boolean {\r\n            if (this._alpha < this._threshold) {\r\n                this._running = false;\r\n                this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });\r\n                return true;\r\n            }\r\n            const n = this._nodes.length,\r\n                  m = this._links.length;\r\n            let o, i;\r\n\r\n            this._descent.locks.clear();\r\n            for (i = 0; i < n; ++i) {\r\n                o = this._nodes[i];\r\n                if (o.fixed) {\r\n                    if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\r\n                        o.px = o.x;\r\n                        o.py = o.y;\r\n                    }\r\n                    var p = [o.px, o.py];\r\n                    this._descent.locks.add(i, p);\r\n                }\r\n            }\r\n\r\n            let s1 = this._descent.rungeKutta();\r\n            //var s1 = descent.reduceStress();\r\n            if (s1 === 0) {\r\n                this._alpha = 0;\r\n            } else if (typeof this._lastStress !== 'undefined') {\r\n                this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);\r\n            }\r\n            this._lastStress = s1;\r\n\r\n            this.updateNodePositions();\r\n\r\n            this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });\r\n            return false;\r\n        }\r\n\r\n        // copy positions out of descent instance into each of the nodes' center coords\r\n        private updateNodePositions(): void {\r\n            const x = this._descent.x[0], y = this._descent.x[1];\r\n            let o, i = this._nodes.length;\r\n            while (i--) {\r\n                o = this._nodes[i];\r\n                o.x = x[i];\r\n                o.y = y[i];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * the list of nodes.\r\n         * If nodes has not been set, but links has, then we instantiate a nodes list here, of the correct size,\r\n         * before returning it.\r\n         * @property nodes {Array}\r\n         * @default empty list\r\n         */\r\n        nodes(): Array<Node>\r\n        nodes(v: Array<InputNode>): this\r\n        nodes(v?: any): any {\r\n            if (!v) {\r\n                if (this._nodes.length === 0 && this._links.length > 0) {\r\n                    // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.\r\n                    // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes\r\n                    var n = 0;\r\n                    this._links.forEach(function (l) {\r\n                        n = Math.max(n, <number>l.source, <number>l.target);\r\n                    });\r\n                    this._nodes = new Array(++n);\r\n                    for (var i = 0; i < n; ++i) {\r\n                        this._nodes[i] = {};\r\n                    }\r\n                }\r\n                return this._nodes;\r\n            }\r\n            this._nodes = v;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * a list of hierarchical groups defined over nodes\r\n         * @property groups {Array}\r\n         * @default empty list\r\n         */\r\n        groups(): Array<Group>\r\n        groups(x: Array<Group>): this\r\n        groups(x?: Array<Group>): any {\r\n            if (!x) return this._groups;\r\n            this._groups = x;\r\n            this._rootGroup = {};\r\n            this._groups.forEach(g => {\r\n                if (typeof g.padding === \"undefined\")\r\n                    g.padding = 1;\r\n                if (typeof g.leaves !== \"undefined\") {\r\n                    g.leaves.forEach((v, i) => {\r\n                        if (typeof v === 'number')\r\n                            (g.leaves[i] = this._nodes[v]).parent = g\r\n                    });\r\n                }\r\n                if (typeof g.groups !== \"undefined\") {\r\n                    g.groups.forEach((gi, i) => {\r\n                        if (typeof gi === 'number')\r\n                            (g.groups[i] = this._groups[gi]).parent = g\r\n                    });\r\n                }\r\n            });\r\n            this._rootGroup.leaves = this._nodes.filter(v => typeof v.parent === 'undefined');\r\n            this._rootGroup.groups = this._groups.filter(g => typeof g.parent === 'undefined');\r\n            return this;\r\n        }\r\n\r\n        powerGraphGroups(f: Function): this {\r\n            var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\r\n            this.groups(g.groups);\r\n            f(g);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * if true, the layout will not permit overlaps of the node bounding boxes (defined by the width and height properties on nodes)\r\n         * @property avoidOverlaps\r\n         * @type bool\r\n         * @default false\r\n         */\r\n        avoidOverlaps(): boolean\r\n        avoidOverlaps(v: boolean): this\r\n        avoidOverlaps(v?: boolean): any {\r\n            if (!arguments.length) return this._avoidOverlaps;\r\n            this._avoidOverlaps = v;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * if true, the final step of the start method will be to nicely pack connected components of the graph.\r\n         * works best if start() is called with a reasonable number of iterations specified and\r\n         * each node has a bounding box (defined by the width and height properties on nodes).\r\n         * @property handleDisconnected\r\n         * @type bool\r\n         * @default true\r\n         */\r\n        handleDisconnected(): boolean\r\n        handleDisconnected(v: boolean): this\r\n        handleDisconnected(v?: boolean): any {\r\n            if (!arguments.length) return this._handleDisconnected;\r\n            this._handleDisconnected = v;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.\r\n         * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)\r\n         * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom\r\n         * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link\r\n         */\r\n        flowLayout(axis: string, minSeparation: number|((t: any)=>number)): this {\r\n            if (!arguments.length) axis = 'y';\r\n            this._directedLinkConstraints = {\r\n                axis: axis,\r\n                getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation } : minSeparation\r\n            };\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * links defined as source, target pairs over nodes\r\n         * @property links {array}\r\n         * @default empty list\r\n         */\r\n        links(): Array<Link<Node|number>>\r\n        links(x: Array<Link<Node|number>>): this\r\n        links(x?: Array<Link<Node|number>>): any {\r\n            if (!arguments.length) return this._links;\r\n            this._links = x;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * list of constraints of various types\r\n         * @property constraints\r\n         * @type {array}\r\n         * @default empty list\r\n         */\r\n        constraints(): Array<any>\r\n        constraints(c: Array<any>): this\r\n        constraints(c?: Array<any>): any {\r\n            if (!arguments.length) return this._constraints;\r\n            this._constraints = c;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Matrix of ideal distances between all pairs of nodes.\r\n         * If unspecified, the ideal distances for pairs of nodes will be based on the shortest path distance between them.\r\n         * @property distanceMatrix\r\n         * @type {Array of Array of Number}\r\n         * @default null\r\n         */\r\n        distanceMatrix(): Array<Array<number>>\r\n        distanceMatrix(d: Array<Array<number>>): this\r\n        distanceMatrix(d?: any): any {\r\n            if (!arguments.length) return this._distanceMatrix;\r\n            this._distanceMatrix = d;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Size of the layout canvas dimensions [x,y]. Currently only used to determine the midpoint which is taken as the starting position\r\n         * for nodes with no preassigned x and y.\r\n         * @property size\r\n         * @type {Array of Number}\r\n         */\r\n        size(): Array<number>\r\n        size(x: Array<number>): this\r\n        size(x?: Array<number>): any {\r\n            if (!x) return this._canvasSize;\r\n            this._canvasSize = x;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Default size (assume nodes are square so both width and height) to use in packing if node width/height are not specified.\r\n         * @property defaultNodeSize\r\n         * @type {Number}\r\n         */\r\n        defaultNodeSize(): number\r\n        defaultNodeSize(x: number): this\r\n        defaultNodeSize(x?: any): any {\r\n            if (!x) return this._defaultNodeSize;\r\n            this._defaultNodeSize = x;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * The strength of attraction between the group boundaries to each other.\r\n         * @property defaultNodeSize\r\n         * @type {Number}\r\n         */\r\n        groupCompactness(): number\r\n        groupCompactness(x: number): this\r\n        groupCompactness(x?: any): any {\r\n            if (!x) return this._groupCompactness;\r\n            this._groupCompactness = x;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * links have an ideal distance, The automatic layout will compute layout that tries to keep links (AKA edges) as close as possible to this length.\r\n         */\r\n        linkDistance(): number\r\n        linkDistance(): LinkNumericPropertyAccessor\r\n        linkDistance(x: number): this\r\n        linkDistance(x: LinkNumericPropertyAccessor): this\r\n        linkDistance(x?: any): any {\r\n            if (!x) {\r\n                return this._linkDistance;\r\n            }\r\n            this._linkDistance = typeof x === \"function\" ? x : +x;\r\n            this._linkLengthCalculator = null;\r\n            return this;\r\n        }\r\n\r\n        linkType(f: Function | number): this {\r\n            this._linkType = f;\r\n            return this;\r\n        }\r\n\r\n        convergenceThreshold(): number\r\n        convergenceThreshold(x: number): this\r\n        convergenceThreshold(x?: number): any {\r\n            if (!x) return this._threshold;\r\n            this._threshold = typeof x === \"function\" ? x : +x;\r\n            return this;\r\n        }\r\n\r\n        alpha(): number\r\n        alpha(x: number): this\r\n        alpha(x?: number): any {\r\n            if (!arguments.length) return this._alpha;\r\n            else {\r\n                x = +x;\r\n                if (this._alpha) { // if we're already running\r\n                    if (x > 0) this._alpha = x; // we might keep it hot\r\n                    else this._alpha = 0; // or, next tick will dispatch \"end\"\r\n                } else if (x > 0) { // otherwise, fire it up!\r\n                    if (!this._running) {\r\n                        this._running = true;\r\n                        this.trigger({ type: EventType.start, alpha: this._alpha = x});\r\n                        this.kick();\r\n                    }\r\n                }\r\n                return this;\r\n            }\r\n        }\r\n\r\n        getLinkLength(link: Link<Node | number>): number {\r\n            return typeof this._linkDistance === \"function\" ? +((<LinkNumericPropertyAccessor>this._linkDistance)(link)) : <number>this._linkDistance;\r\n        }\r\n\r\n        static setLinkLength(link: Link<Node|number>, length: number) {\r\n            link.length = length;\r\n        }\r\n\r\n        getLinkType(link: Link<Node | number>): number {\r\n            return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\r\n        }\r\n\r\n        linkAccessor: LinkLengthTypeAccessor = {\r\n            getSourceIndex: Layout.getSourceIndex,\r\n            getTargetIndex: Layout.getTargetIndex,\r\n            setLength: Layout.setLinkLength,\r\n            getType: l => typeof this._linkType === \"function\" ? this._linkType(l) : 0\r\n        };\r\n\r\n        /**\r\n         * compute an ideal length for each link based on the graph structure around that link.\r\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\r\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\r\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)\r\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\r\n         * don't have to have been assigned before invoking this function.\r\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\r\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\r\n         */\r\n        symmetricDiffLinkLengths(idealLength: number, w: number = 1): this {\r\n            this.linkDistance(l => idealLength * l.length);\r\n            this._linkLengthCalculator = () => symmetricDiffLinkLengths(this._links, this.linkAccessor, w);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * compute an ideal length for each link based on the graph structure around that link.\r\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\r\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\r\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|\r\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\r\n         * don't have to have been assigned before invoking this function.\r\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\r\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\r\n         */\r\n        jaccardLinkLengths(idealLength: number, w: number = 1): this {\r\n            this.linkDistance(l => idealLength * l.length);\r\n            this._linkLengthCalculator = () => jaccardLinkLengths(this._links, this.linkAccessor, w);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * start the layout process\r\n         * @method start\r\n         * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations\r\n         * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints\r\n         * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap\r\n         * @param {number} [gridSnapIterations=0] iterations of \"grid snap\", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height\r\n         * @param [keepRunning=true] keep iterating asynchronously via the tick method\r\n         */\r\n        start(\r\n            initialUnconstrainedIterations: number = 0,\r\n            initialUserConstraintIterations: number = 0,\r\n            initialAllConstraintsIterations: number = 0,\r\n            gridSnapIterations: number = 0,\r\n            keepRunning = true\r\n        ): this {\r\n            var i: number,\r\n                j: number,\r\n                n = (<Array<any>>this.nodes()).length,\r\n                N = n + 2 * this._groups.length,\r\n                m = this._links.length,\r\n                w = this._canvasSize[0],\r\n                h = this._canvasSize[1];\r\n\r\n            var x = new Array(N), y = new Array(N);\r\n\r\n            var G = null;\r\n\r\n            var ao = this._avoidOverlaps;\r\n\r\n            this._nodes.forEach((v, i) => {\r\n                v.index = i;\r\n                if (typeof v.x === 'undefined') {\r\n                    v.x = w / 2, v.y = h / 2;\r\n                }\r\n                x[i] = v.x, y[i] = v.y;\r\n            });\r\n\r\n            if (this._linkLengthCalculator) this._linkLengthCalculator();\r\n\r\n            //should we do this to clearly label groups?\r\n            //this._groups.forEach((g, i) => g.groupIndex = i);\r\n\r\n            var distances;\r\n            if (this._distanceMatrix) {\r\n                // use the user specified distanceMatrix\r\n                distances = this._distanceMatrix;\r\n            } else {\r\n                // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).\r\n                distances = (new Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, l=> this.getLinkLength(l))).DistanceMatrix();\r\n\r\n                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\r\n                // otherwise 2. (\r\n                G = Descent.createSquareMatrix(N, () => 2);\r\n                this._links.forEach(l => {\r\n                    if (typeof l.source == \"number\") l.source = this._nodes[<number>l.source];\r\n                    if (typeof l.target == \"number\") l.target = this._nodes[<number>l.target];\r\n                });\r\n                this._links.forEach(e => {\r\n                    const u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);\r\n                    G[u][v] = G[v][u] = e.weight || 1;\r\n                });\r\n            }\r\n\r\n            var D = Descent.createSquareMatrix(N, function (i, j) {\r\n                return distances[i][j];\r\n            });\r\n\r\n            if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\r\n                var i = n;\r\n                var addAttraction = (i, j, strength, idealDistance) => {\r\n                    G[i][j] = G[j][i] = strength;\r\n                    D[i][j] = D[j][i] = idealDistance;\r\n                };\r\n                this._groups.forEach(g => {\r\n                    addAttraction(i, i + 1, this._groupCompactness, 0.1);\r\n\r\n                    // todo: add terms here attracting children of the group to the group dummy nodes\r\n                    //if (typeof g.leaves !== 'undefined')\r\n                    //    g.leaves.forEach(l => {\r\n                    //        addAttraction(l.index, i, 1e-4, 0.1);\r\n                    //        addAttraction(l.index, i + 1, 1e-4, 0.1);\r\n                    //    });\r\n                    //if (typeof g.groups !== 'undefined')\r\n                    //    g.groups.forEach(g => {\r\n                    //        var gid = n + g.groupIndex * 2;\r\n                    //        addAttraction(gid, i, 0.1, 0.1);\r\n                    //        addAttraction(gid + 1, i, 0.1, 0.1);\r\n                    //        addAttraction(gid, i + 1, 0.1, 0.1);\r\n                    //        addAttraction(gid + 1, i + 1, 0.1, 0.1);\r\n                    //    });\r\n\r\n                    x[i] = 0, y[i++] = 0;\r\n                    x[i] = 0, y[i++] = 0;\r\n                });\r\n            } else this._rootGroup = { leaves: this._nodes, groups: [] };\r\n\r\n            var curConstraints = this._constraints || [];\r\n            if (this._directedLinkConstraints) {\r\n                (<any>this.linkAccessor).getMinSeparation = this._directedLinkConstraints.getMinSeparation;\r\n                curConstraints = curConstraints.concat(generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, <any>(this.linkAccessor)));\r\n\r\n                // todo: add containment constraints between group dummy nodes and their children\r\n            }\r\n\r\n            this.avoidOverlaps(false);\r\n            this._descent = new Descent([x, y], D);\r\n\r\n            this._descent.locks.clear();\r\n            for (var i = 0; i < n; ++i) {\r\n                var o = this._nodes[i];\r\n                if (o.fixed) {\r\n                    o.px = o.x;\r\n                    o.py = o.y;\r\n                    var p = [o.x, o.y];\r\n                    this._descent.locks.add(i, p);\r\n                }\r\n            }\r\n            this._descent.threshold = this._threshold;\r\n\r\n            // apply initialIterations without user constraints or nonoverlap constraints\r\n            // if groups are specified, dummy nodes and edges will be added to untangle\r\n            // with respect to group connectivity\r\n            this.initialLayout(initialUnconstrainedIterations, x, y);\r\n\r\n            // apply initialIterations with user constraints but no nonoverlap constraints\r\n            if (curConstraints.length > 0) this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\r\n            this._descent.run(initialUserConstraintIterations);\r\n            this.separateOverlappingComponents(w, h);\r\n\r\n            // subsequent iterations will apply all constraints\r\n            this.avoidOverlaps(ao);\r\n            if (ao) {\r\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\r\n                this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\r\n                this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });\r\n            }\r\n\r\n            // allow not immediately connected nodes to relax apart (p-stress)\r\n            this._descent.G = G;\r\n            this._descent.run(initialAllConstraintsIterations);\r\n\r\n            if (gridSnapIterations) {\r\n                this._descent.snapStrength = 1000;\r\n                this._descent.snapGridSize = this._nodes[0].width;\r\n                this._descent.numGridSnapNodes = n;\r\n                this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply\r\n                var G0 = Descent.createSquareMatrix(N,(i, j) => {\r\n                    if (i >= n || j >= n) return G[i][j];\r\n                    return 0\r\n                });\r\n                this._descent.G = G0;\r\n                this._descent.run(gridSnapIterations);\r\n            }\r\n\r\n            this.updateNodePositions();\r\n            this.separateOverlappingComponents(w, h);\r\n            return keepRunning ? this.resume() : this;\r\n        }\r\n\r\n        private initialLayout(iterations: number, x: number[], y: number[]) {\r\n            if (this._groups.length > 0 && iterations > 0) {\r\n                // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\r\n                // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node\r\n                var n = this._nodes.length;\r\n                var edges = this._links.map(e => <any>{ source: (<Node>e.source).index, target: (<Node>e.target).index });\r\n                var vs = this._nodes.map(v => <any>{ index: v.index });\r\n                this._groups.forEach((g, i) => {\r\n                    vs.push(<any>{ index: g.index = n + i });\r\n                });\r\n                this._groups.forEach((g, i) => {\r\n                    if (typeof g.leaves !== 'undefined')\r\n                        g.leaves.forEach(v => edges.push({ source: g.index, target: v.index }));\r\n                    if (typeof g.groups !== 'undefined')\r\n                        g.groups.forEach(gg => edges.push({ source: g.index, target: gg.index }));\r\n                });\r\n\r\n                // layout the flat graph with dummy nodes and edges\r\n                new Layout()\r\n                    .size(this.size())\r\n                    .nodes(vs)\r\n                    .links(edges)\r\n                    .avoidOverlaps(false)\r\n                    .linkDistance(this.linkDistance())\r\n                    .symmetricDiffLinkLengths(5)\r\n                    .convergenceThreshold(1e-4)\r\n                    .start(iterations, 0, 0, 0, false);\r\n\r\n                this._nodes.forEach(v => {\r\n                    x[v.index] = vs[v.index].x;\r\n                    y[v.index] = vs[v.index].y;\r\n                });\r\n            } else {\r\n                this._descent.run(iterations);\r\n            }\r\n        }\r\n\r\n        // recalculate nodes position for disconnected graphs\r\n        private separateOverlappingComponents(width: number, height: number): void {\r\n            // recalculate nodes position for disconnected graphs\r\n            if (!this._distanceMatrix && this._handleDisconnected) {\r\n                let x = this._descent.x[0], y = this._descent.x[1];\r\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\r\n                var graphs = separateGraphs(this._nodes, this._links);\r\n                applyPacking(graphs, width, height, this._defaultNodeSize);\r\n                this._nodes.forEach((v, i) => {\r\n                    this._descent.x[0][i] = v.x, this._descent.x[1][i] = v.y;\r\n                    if (v.bounds) {\r\n                        v.bounds.setXCentre(v.x);\r\n                        v.bounds.setYCentre(v.y);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        resume(): this {\r\n            return this.alpha(0.1);\r\n        }\r\n\r\n        stop(): this {\r\n            return this.alpha(0);\r\n        }\r\n\r\n        /// find a visibility graph over the set of nodes.  assumes all nodes have a\r\n        /// bounds property (a rectangle) and that no pair of bounds overlaps.\r\n        prepareEdgeRouting(nodeMargin: number = 0) {\r\n            this._visibilityGraph = new TangentVisibilityGraph(\r\n                this._nodes.map(function (v) {\r\n                    return v.bounds.inflate(-nodeMargin).vertices();\r\n                }));\r\n        }\r\n\r\n        /**\r\n         * find a route avoiding node bounds for the given edge.\r\n         * assumes the visibility graph has been created (by prepareEdgeRouting method)\r\n         * and also assumes that nodes have an index property giving their position in the\r\n         * node array.  This index property is created by the start() method.\r\n         * @param [edge] The edge to generate a route for.\r\n         * @param {number} [ah] The size of the arrow head, a distance to shorten the end\r\n         *                      of the edge by.  Defaults to 5.\r\n         */\r\n        routeEdge(edge, ah: number = 5, draw) {\r\n            var lineData = [];\r\n            //if (d.source.id === 10 && d.target.id === 11) {\r\n            //    debugger;\r\n            //}\r\n            var vg2 = new TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }),\r\n                port1 = <TVGPoint>{ x: edge.source.x, y: edge.source.y },\r\n                port2 = <TVGPoint>{ x: edge.target.x, y: edge.target.y },\r\n                start = vg2.addPoint(port1, edge.source.index),\r\n                end = vg2.addPoint(port2, edge.target.index);\r\n            vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\r\n            if (typeof draw !== 'undefined') {\r\n                draw(vg2);\r\n            }\r\n            var sourceInd = e => e.source.id, targetInd = e => e.target.id, length = e => e.length(),\r\n                spCalc = new Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length),\r\n                shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\r\n            if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\r\n                let route = makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);\r\n                lineData = [route.sourceIntersection, route.arrowStart];\r\n            } else {\r\n                var n = shortestPath.length - 2,\r\n                    p = vg2.V[shortestPath[n]].p,\r\n                    q = vg2.V[shortestPath[0]].p,\r\n                    lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\r\n                for (var i = n; i >= 0; --i)\r\n                    lineData.push(vg2.V[shortestPath[i]].p);\r\n                lineData.push(makeEdgeTo(q, edge.target.innerBounds, ah));\r\n            }\r\n            //lineData.forEach((v, i) => {\r\n            //    if (i > 0) {\r\n            //        var u = lineData[i - 1];\r\n            //        this._nodes.forEach(function (node) {\r\n            //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;\r\n            //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);\r\n            //            if (ints.length > 0) {\r\n            //                debugger;\r\n            //            }\r\n            //        })\r\n            //    }\r\n            //})\r\n            return lineData;\r\n        }\r\n\r\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\r\n        static getSourceIndex(e: Link<Node | number>): number {\r\n            return typeof e.source === 'number' ? <number>e.source : (<Node>e.source).index;\r\n        }\r\n\r\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\r\n        static getTargetIndex(e: Link<Node | number>): number {\r\n            return typeof e.target === 'number' ? <number>e.target : (<Node>e.target).index;\r\n        }\r\n\r\n        // Get a string ID for a given link.\r\n        static linkId(e: Link<Node | number>): string {\r\n            return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\r\n        }\r\n\r\n        // The fixed property has three bits:\r\n        // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.\r\n        // Bit 2 stores the dragging state, from mousedown to mouseup.\r\n        // Bit 3 stores the hover state, from mouseover to mouseout.\r\n        static dragStart(d: Node | Group) {\r\n            if (isGroup(d)) {\r\n                Layout.storeOffset(d, Layout.dragOrigin(d));\r\n            } else {\r\n                Layout.stopNode(d);\r\n                d.fixed |= 2; // set bit 2\r\n            }\r\n        }\r\n\r\n        // we clobber any existing desired positions for nodes\r\n        // in case another tick event occurs before the drag\r\n        private static stopNode(v: Node) {\r\n            (<any>v).px = v.x;\r\n            (<any>v).py = v.y;\r\n        }\r\n\r\n        // we store offsets for each node relative to the centre of the ancestor group\r\n        // being dragged in a pair of properties on the node\r\n        private static storeOffset(d: Group, origin: { x: number, y: number }) {\r\n            if (typeof d.leaves !== 'undefined') {\r\n                d.leaves.forEach(v => {\r\n                    v.fixed |= 2;\r\n                    Layout.stopNode(v);\r\n                    (<any>v)._dragGroupOffsetX = v.x - origin.x;\r\n                    (<any>v)._dragGroupOffsetY = v.y - origin.y;\r\n                });\r\n            }\r\n            if (typeof d.groups !== 'undefined') {\r\n                d.groups.forEach(g => Layout.storeOffset(g, origin));\r\n            }\r\n        }\r\n\r\n        // the drag origin is taken as the centre of the node or group\r\n        static dragOrigin(d: Node | Group): { x: number, y: number } {\r\n            if (isGroup(d)) {\r\n                return {\r\n                    x: d.bounds.cx(),\r\n                    y: d.bounds.cy()\r\n                };\r\n            } else {\r\n                return d;\r\n            }\r\n        }\r\n\r\n        // for groups, the drag translation is propagated down to all of the children of\r\n        // the group.\r\n        static drag(d: Node | Group, position: { x: number, y: number }) {\r\n            if (isGroup(d)) {\r\n                if (typeof d.leaves !== 'undefined') {\r\n                    d.leaves.forEach(v => {\r\n                        d.bounds.setXCentre(position.x);\r\n                        d.bounds.setYCentre(position.y);\r\n                        (<any>v).px = (<any>v)._dragGroupOffsetX + position.x;\r\n                        (<any>v).py = (<any>v)._dragGroupOffsetY + position.y;\r\n                    });\r\n                }\r\n                if (typeof d.groups !== 'undefined') {\r\n                    d.groups.forEach(g => Layout.drag(g, position));\r\n                }\r\n            } else {\r\n                (<any>d).px = position.x;\r\n                (<any>d).py = position.y;\r\n            }\r\n        }\r\n\r\n        // we unset only bits 2 and 3 so that the user can fix nodes with another a different\r\n        // bit such that the lock persists between drags\r\n        static dragEnd(d) {\r\n            if (isGroup(d)) {\r\n                if (typeof d.leaves !== 'undefined') {\r\n                    d.leaves.forEach(v => {\r\n                        Layout.dragEnd(v);\r\n                        delete (<any>v)._dragGroupOffsetX;\r\n                        delete (<any>v)._dragGroupOffsetY;\r\n                    });\r\n                }\r\n                if (typeof d.groups !== 'undefined') {\r\n                    d.groups.forEach(Layout.dragEnd);\r\n                }\r\n            } else {\r\n                d.fixed &= ~6; // unset bits 2 and 3\r\n                //d.fixed = 0;\r\n            }\r\n        }\r\n\r\n        // in d3 hover temporarily locks nodes, currently not used in cola\r\n        static mouseOver(d) {\r\n            d.fixed |= 4; // set bit 3\r\n            d.px = d.x, d.py = d.y; // set velocity to zero\r\n        }\r\n\r\n        // in d3 hover temporarily locks nodes, currently not used in cola\r\n        static mouseOut(d) {\r\n            d.fixed &= ~4; // unset bit 3\r\n        }\r\n    }\r\n"]}},"hash":"9eaef82454efa271c237dabecbda0463","cacheData":{"env":{}}}